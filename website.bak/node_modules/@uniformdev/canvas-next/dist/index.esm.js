import {
  resolveSlugFromParams
} from "./chunk-TR7V6ABJ.mjs";

// src/preview/previewHandlerGet.ts
import { IN_CONTEXT_EDITOR_QUERY_STRING_PARAM } from "@uniformdev/canvas";
var getQueryParam = (req, paramName) => {
  const value = req.query[paramName];
  if (typeof value === "undefined") {
    return void 0;
  }
  return Array.isArray(value) ? value[0] : value;
};
var createPreviewHandlerGet = ({ secret, resolveFullPath = resolveFullPathDefault } = {}) => async (req, res) => {
  if (req.headers["sec-fetch-mode"] === "no-cors") {
    return res.status(204).end();
  }
  const queryParamsToPreserve = [IN_CONTEXT_EDITOR_QUERY_STRING_PARAM];
  const id = getQueryParam(req, "id");
  const slug = getQueryParam(req, "slug");
  const path = getQueryParam(req, "path");
  const locale = getQueryParam(req, "locale");
  const pathToRedirectTo = resolveFullPath({ id, slug, path, locale });
  validateLocalRedirectUrl(pathToRedirectTo);
  if (!pathToRedirectTo) {
    return res.status(400).json({ message: "Could not resolve the full path of the preview page" });
  }
  if (req.query.disable) {
    res.clearPreviewData();
    res.redirect(pathToRedirectTo);
    return;
  }
  const previewSecret = typeof secret === "function" ? secret == null ? void 0 : secret() : secret;
  const isUsingPreviewSecret = Boolean(previewSecret);
  if (isUsingPreviewSecret && req.query.secret !== previewSecret) {
    return res.status(401).json({ message: "Invalid token" });
  }
  const isUniformContextualEditing = req.query[IN_CONTEXT_EDITOR_QUERY_STRING_PARAM] === "true";
  res.setPreviewData(
    {
      isUniformContextualEditing,
      compositionId: id,
      compositionSlug: slug,
      compositionPath: path,
      locale
    },
    {
      // By default the preview cookies stays as long as the tab is open. And in contextual editing mode, people tend to open Canvas editor (one tab) and another tab to see published changes.
      // This causes the second tab to still have the preview cookie, which causes unexpected behavior.
      // This is more obvious in contextual editing mode because we skip the composition fetching and the user sees a blank page where they expected the published composition.
      // We set this value to `10` just to handle the case of middlewares and redirections, ideally `0` should do the trick.
      maxAge: isUniformContextualEditing ? 10 : void 0
    }
  );
  const cookies = res.getHeader("Set-Cookie");
  res.setHeader(
    "Set-Cookie",
    cookies == null ? void 0 : cookies.map((cookie) => cookie.replace("SameSite=Lax", "SameSite=None;Secure"))
  );
  const newQuery = new URLSearchParams();
  queryParamsToPreserve.forEach((param) => {
    const paramValue = req.query[param];
    if (typeof paramValue === "string") {
      newQuery.append(param, paramValue);
    }
  });
  const urlToRedirectTo = newQuery.toString() ? `${pathToRedirectTo}?${newQuery.toString()}` : pathToRedirectTo;
  res.redirect(urlToRedirectTo);
};
var resolveFullPathDefault = ({ slug, path }) => {
  return path || slug;
};
function validateLocalRedirectUrl(pathToRedirectTo) {
  if (pathToRedirectTo == null ? void 0 : pathToRedirectTo.match(/^[a-z]+:\/\//g)) {
    throw new Error("Tried to redirect to absolute URL with protocol. Disallowing open redirect.");
  }
}

// src/preview/previewHandlerPost.ts
import { generateHash } from "@uniformdev/canvas";
var createPreviewHandlerPost = ({ secret, enhance } = {}) => async (req, res) => {
  const { composition, hash } = req.body;
  if (!composition) {
    return res.status(422).json({ message: 'Missing "composition" parameter' });
  }
  const previewSecret = typeof secret === "function" ? secret == null ? void 0 : secret() : secret;
  const hasProvidedHash = Boolean(hash);
  const hasConfiguredHash = Boolean(previewSecret);
  if (hasProvidedHash && hasConfiguredHash) {
    const calculatedHash = generateHash({
      composition,
      secret: previewSecret
    });
    if (calculatedHash !== hash) {
      return res.status(401).json({ message: "Not authorized" });
    }
  } else if (hasConfiguredHash) {
    return res.status(401).json({ message: "Not authorized" });
  }
  await (enhance == null ? void 0 : enhance(composition, {
    req
  }));
  return res.status(200).json({
    composition
  });
};

// src/preview/previewHandler.ts
var createPreviewHandler = ({ secret, enhance, resolveFullPath } = {}) => async (req, res) => {
  var _a;
  const method = (_a = req.method) == null ? void 0 : _a.toLocaleLowerCase();
  if (method === "get") {
    return createPreviewHandlerGet({ secret, resolveFullPath })(req, res);
  } else if (method === "post") {
    return createPreviewHandlerPost({ secret, enhance })(req, res);
  } else if (method === "options") {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Origin, Content-Type, Accept");
    res.setHeader("Access-Control-Allow-Methods", "GET");
    return res.status(204);
  }
  return res.status(501).json({ message: `Method "${method}" not implemented` });
};
export {
  createPreviewHandler,
  createPreviewHandlerGet,
  createPreviewHandlerPost,
  resolveSlugFromParams
};
