"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/route/index.ts
var route_exports = {};
__export(route_exports, {
  getStaticPaths: () => getStaticPaths2,
  unstable_getServerSideProps: () => unstable_getServerSideProps,
  unstable_getStaticProps: () => unstable_getStaticProps,
  unstable_withUniformGetServerSideProps: () => unstable_withUniformGetServerSideProps,
  unstable_withUniformGetStaticProps: () => unstable_withUniformGetStaticProps,
  withUniformGetStaticPaths: () => withUniformGetStaticPaths
});
module.exports = __toCommonJS(route_exports);

// src/project-map/withUniformGetServerSideProps.ts
var import_canvas = require("@uniformdev/canvas");
var withUniformGetServerSideProps = (options) => {
  const canvasClient = (options == null ? void 0 : options.client) || new import_canvas.CanvasClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    apiHost: process.env.UNIFORM_CLI_BASE_URL,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  return async function wrappedGetServerSideProps(context) {
    var _a, _b;
    const projectMapId = (_a = options == null ? void 0 : options.projectMapId) != null ? _a : process.env.UNIFORM_PROJECT_MAP_ID;
    const { preview, previewData } = context;
    let composition = void 0;
    let nodePath = (options == null ? void 0 : options.prefix) ? context.resolvedUrl.replace(new RegExp(`^${options.prefix}`), "") : context.resolvedUrl;
    if (options == null ? void 0 : options.modifyPath) {
      nodePath = options.modifyPath(nodePath, context);
    }
    if (previewData == null ? void 0 : previewData.isUniformContextualEditing) {
      composition = { ...import_canvas.EMPTY_COMPOSITION, _id: (_b = previewData.compositionId) != null ? _b : import_canvas.EMPTY_COMPOSITION._id };
    } else {
      try {
        const time = Date.now();
        const response = await canvasClient.getCompositionByNodePath({
          ...options == null ? void 0 : options.requestOptions,
          projectMapId,
          projectMapNodePath: nodePath,
          state: preview || (options == null ? void 0 : options.preview) ? import_canvas.CANVAS_DRAFT_STATE : import_canvas.CANVAS_PUBLISHED_STATE
        });
        const duration = Date.now() - time;
        composition = response.composition;
        if (!(options == null ? void 0 : options.silent)) {
          (0, import_canvas.logCompositionResponse)(response, duration);
        }
      } catch (e) {
        console.error("[canvas-next] Failed to fetch composition", e);
        return {
          notFound: true
        };
      }
    }
    const ret = (options == null ? void 0 : options.callback) ? await options.callback(context, composition) : { props: {} };
    if (Object.hasOwn(ret, "props")) {
      const casted = ret;
      casted.props["data"] = composition;
    }
    return ret;
  };
};

// src/project-map/withUniformGetStaticPaths.ts
var import_canvas2 = require("@uniformdev/canvas");
var import_project_map = require("@uniformdev/project-map");
var withUniformGetStaticPaths = (options) => {
  return async function wrappedGetStaticPaths() {
    var _a, _b;
    const projectMapId = (_a = options == null ? void 0 : options.projectMapId) != null ? _a : process.env.UNIFORM_PROJECT_MAP_ID;
    const projectMapClient = (_b = options == null ? void 0 : options.client) != null ? _b : new import_project_map.ProjectMapClient({
      apiKey: process.env.UNIFORM_API_KEY,
      projectId: process.env.UNIFORM_PROJECT_ID,
      apiHost: process.env.UNIFORM_CLI_BASE_URL
    });
    const response = await projectMapClient.getNodes({
      ...options == null ? void 0 : options.requestOptions,
      path: options == null ? void 0 : options.rootPath,
      projectMapId,
      state: (options == null ? void 0 : options.preview) ? import_canvas2.CANVAS_DRAFT_STATE : import_canvas2.CANVAS_PUBLISHED_STATE
    });
    const nodes = (options == null ? void 0 : options.callback) ? await options.callback(response.nodes) : response.nodes;
    const paths = nodes == null ? void 0 : nodes.filter((node) => Boolean(node.compositionId)).map((node) => {
      var _a2;
      return `${(_a2 = options == null ? void 0 : options.prefix) != null ? _a2 : ""}${node.path}`;
    });
    return {
      paths,
      fallback: true
    };
  };
};

// src/project-map/withUniformGetStaticProps.ts
var import_canvas3 = require("@uniformdev/canvas");

// src/helpers/resolveSlugFromParams.ts
var resolveSlugFromParams = ({
  param = "slug",
  params
}) => {
  const slug = (params == null ? void 0 : params[param]) || "";
  const slugString = Array.isArray(slug) ? slug.join("/") : slug;
  return `/${slugString}`;
};

// src/project-map/withUniformGetStaticProps.ts
var withUniformGetStaticProps = (options) => {
  var _a;
  const canvasClient = (_a = options == null ? void 0 : options.client) != null ? _a : new import_canvas3.CanvasClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    apiHost: process.env.UNIFORM_CLI_BASE_URL,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  return async function wrappedGetStaticProps(context) {
    var _a2, _b;
    const projectMapId = (_a2 = options == null ? void 0 : options.projectMapId) != null ? _a2 : process.env.UNIFORM_PROJECT_MAP_ID;
    let pathString = resolveSlugFromParams({
      param: options == null ? void 0 : options.param,
      params: context == null ? void 0 : context.params
    });
    if (options == null ? void 0 : options.modifyPath) {
      pathString = options.modifyPath(pathString, context);
    }
    const { preview, previewData } = context;
    let composition = void 0;
    if (previewData == null ? void 0 : previewData.isUniformContextualEditing) {
      composition = { ...import_canvas3.EMPTY_COMPOSITION, _id: (_b = previewData.compositionId) != null ? _b : import_canvas3.EMPTY_COMPOSITION._id };
    } else {
      try {
        const time = Date.now();
        const response = await canvasClient.getCompositionByNodePath({
          ...options == null ? void 0 : options.requestOptions,
          projectMapId,
          projectMapNodePath: pathString,
          state: preview || (options == null ? void 0 : options.preview) ? import_canvas3.CANVAS_DRAFT_STATE : import_canvas3.CANVAS_PUBLISHED_STATE
        });
        const duration = Date.now() - time;
        composition = response.composition;
        if (!(options == null ? void 0 : options.silent)) {
          (0, import_canvas3.logCompositionResponse)(response, duration);
        }
      } catch (e) {
        console.error("[canvas-next] Failed to fetch composition", e);
        return {
          notFound: true
        };
      }
    }
    const ret = options.callback ? await options.callback(context, composition) : { props: {} };
    if (composition && Object.hasOwn(ret, "props")) {
      const casted = ret;
      casted.props["data"] = composition;
    }
    return ret;
  };
};

// src/project-map/index.ts
var getServerSideProps = withUniformGetServerSideProps();
var getStaticProps = withUniformGetStaticProps({ param: "path" });
var getStaticPaths = withUniformGetStaticPaths();

// src/route/withUniformGetServerSideProps.ts
var import_redirect = require("@uniformdev/redirect");

// src/route/createRouteFetcher.ts
var import_canvas4 = require("@uniformdev/canvas");
var import_ansi_colors = __toESM(require("ansi-colors"));
var { red } = import_ansi_colors.default;
function createRouteFetcher(options) {
  const {
    handleNotFound,
    handleComposition,
    handleRedirect,
    defaultHandleComposition,
    defaultHandleNotFound,
    defaultHandleRedirect,
    modifyPath,
    projectMapId = process.env.UNIFORM_PROJECT_MAP_ID,
    client,
    prefix,
    requestOptions,
    silent,
    parseContext
  } = options;
  const routeClient = client || new import_canvas4.unstable_RouteClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  const handleModifyPath = modifyPath != null ? modifyPath : (path) => decodeURI(path);
  return async function fetcher(context) {
    const { contextualEditingCompositionId, resolvedUrl } = parseContext(context);
    let nodePath = prefix ? resolvedUrl.replace(new RegExp(`^${prefix}`), "") : resolvedUrl;
    nodePath = handleModifyPath(nodePath, context);
    const invokeRedirectResult = (redirect, duration) => (handleRedirect != null ? handleRedirect : defaultHandleRedirect)(
      nodePath,
      redirect,
      context,
      (response) => defaultHandleRedirect(
        nodePath,
        response,
        context,
        () => {
          throw new Error();
        },
        duration
      ),
      duration
    );
    const invokeNotFoundResult = (response, duration) => (handleNotFound != null ? handleNotFound : defaultHandleNotFound)(
      response,
      context,
      (response2) => defaultHandleNotFound(
        response2,
        context,
        () => {
          throw new Error();
        },
        duration
      ),
      duration
    );
    const invokeCompositionResult = (response, duration) => (handleComposition != null ? handleComposition : defaultHandleComposition)(
      response,
      context,
      (response2) => defaultHandleComposition(
        response2,
        context,
        () => {
          throw new Error();
        },
        duration
      ),
      duration
    );
    if (contextualEditingCompositionId) {
      const previewEmptyComposition = await invokeCompositionResult(
        {
          type: "composition",
          matchedRoute: "contextual-editing",
          compositionApiResponse: {
            composition: {
              ...import_canvas4.EMPTY_COMPOSITION,
              _id: contextualEditingCompositionId != null ? contextualEditingCompositionId : import_canvas4.EMPTY_COMPOSITION._id
            }
          }
        },
        0
      );
      return previewEmptyComposition;
    } else {
      try {
        if (!silent) {
          console.log("Fetch route", nodePath);
        }
        const time = Date.now();
        const response = await routeClient.getRoute({
          ...requestOptions,
          projectMapId,
          path: nodePath
        });
        const duration = Date.now() - time;
        if (!silent) {
          (0, import_canvas4.logRouteResponse)(response, duration);
        }
        if (response.type === "redirect") {
          return invokeRedirectResult(response, duration);
        }
        if (response.type === "notFound") {
          return invokeNotFoundResult(response, duration);
        }
        const handleResult = await invokeCompositionResult(response, duration);
        if (!handleResult) {
          return invokeNotFoundResult({ type: "notFound" }, duration);
        }
        return handleResult;
      } catch (e) {
        console.error(red("Failed to fetch route"), e);
        if (e instanceof import_canvas4.ApiClientError) {
          if (e.statusCode === 404) {
            return invokeNotFoundResult({ type: "notFound" }, 0);
          }
          throw new Error(`Failed to fetch route. See preceding server logs for details.`);
        }
        throw e;
      }
    }
  };
}

// src/route/withUniformGetServerSideProps.ts
var unstable_withUniformGetServerSideProps = (options) => {
  const defaultHandleRedirect = (requestUrl, matched) => {
    return {
      redirect: {
        destination: import_redirect.RedirectClient.getTargetVariableExpandedUrl(requestUrl, matched.redirect),
        statusCode: matched.redirect.targetStatusCode
      }
    };
  };
  const defaultHandleNotFound = () => ({
    notFound: true
  });
  const defaultHandleComposition = async (matched) => {
    return {
      props: {
        data: matched.compositionApiResponse.composition
      }
    };
  };
  const routeFetcher = createRouteFetcher({
    ...options,
    defaultHandleComposition,
    defaultHandleNotFound,
    defaultHandleRedirect,
    parseContext(context) {
      var _a;
      return {
        contextualEditingCompositionId: (_a = context.previewData) == null ? void 0 : _a.compositionId,
        resolvedUrl: context.resolvedUrl
      };
    }
  });
  return routeFetcher;
};

// src/route/withUniformGetStaticProps.ts
var import_redirect2 = require("@uniformdev/redirect");
var unstable_withUniformGetStaticProps = (options) => {
  const defaultHandleRedirect = (requestUrl, matched) => {
    return {
      redirect: {
        destination: import_redirect2.RedirectClient.getTargetVariableExpandedUrl(requestUrl, matched.redirect),
        statusCode: matched.redirect.targetStatusCode
      }
    };
  };
  const defaultHandleNotFound = () => ({
    notFound: true
  });
  const defaultHandleComposition = async (matched) => {
    return {
      props: {
        data: matched.compositionApiResponse.composition
      }
    };
  };
  const routeFetcher = createRouteFetcher({
    ...options,
    defaultHandleComposition,
    defaultHandleNotFound,
    defaultHandleRedirect,
    parseContext(context) {
      var _a, _b;
      return {
        contextualEditingCompositionId: (_a = context.previewData) == null ? void 0 : _a.compositionId,
        resolvedUrl: resolveSlugFromParams({
          params: context.params,
          param: (_b = options == null ? void 0 : options.param) != null ? _b : "route"
        })
      };
    }
  });
  return routeFetcher;
};

// src/route/index.ts
var unstable_getServerSideProps = unstable_withUniformGetServerSideProps();
var unstable_getStaticProps = unstable_withUniformGetStaticProps();
var getStaticPaths2 = withUniformGetStaticPaths();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getStaticPaths,
  unstable_getServerSideProps,
  unstable_getStaticProps,
  unstable_withUniformGetServerSideProps,
  unstable_withUniformGetStaticProps,
  withUniformGetStaticPaths
});
