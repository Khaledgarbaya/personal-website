import {
  withUniformGetStaticPaths
} from "../chunk-ZOXJSPVQ.mjs";
import {
  resolveSlugFromParams
} from "../chunk-TR7V6ABJ.mjs";

// src/route/withUniformGetServerSideProps.ts
import { RedirectClient } from "@uniformdev/redirect";

// src/route/createRouteFetcher.ts
import {
  ApiClientError,
  EMPTY_COMPOSITION,
  logRouteResponse,
  unstable_RouteClient
} from "@uniformdev/canvas";
import ansicolors from "ansi-colors";
var { red } = ansicolors;
function createRouteFetcher(options) {
  const {
    handleNotFound,
    handleComposition,
    handleRedirect,
    defaultHandleComposition,
    defaultHandleNotFound,
    defaultHandleRedirect,
    modifyPath,
    projectMapId = process.env.UNIFORM_PROJECT_MAP_ID,
    client,
    prefix,
    requestOptions,
    silent,
    parseContext
  } = options;
  const routeClient = client || new unstable_RouteClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  const handleModifyPath = modifyPath != null ? modifyPath : (path) => decodeURI(path);
  return async function fetcher(context) {
    const { contextualEditingCompositionId, resolvedUrl } = parseContext(context);
    let nodePath = prefix ? resolvedUrl.replace(new RegExp(`^${prefix}`), "") : resolvedUrl;
    nodePath = handleModifyPath(nodePath, context);
    const invokeRedirectResult = (redirect, duration) => (handleRedirect != null ? handleRedirect : defaultHandleRedirect)(
      nodePath,
      redirect,
      context,
      (response) => defaultHandleRedirect(
        nodePath,
        response,
        context,
        () => {
          throw new Error();
        },
        duration
      ),
      duration
    );
    const invokeNotFoundResult = (response, duration) => (handleNotFound != null ? handleNotFound : defaultHandleNotFound)(
      response,
      context,
      (response2) => defaultHandleNotFound(
        response2,
        context,
        () => {
          throw new Error();
        },
        duration
      ),
      duration
    );
    const invokeCompositionResult = (response, duration) => (handleComposition != null ? handleComposition : defaultHandleComposition)(
      response,
      context,
      (response2) => defaultHandleComposition(
        response2,
        context,
        () => {
          throw new Error();
        },
        duration
      ),
      duration
    );
    if (contextualEditingCompositionId) {
      const previewEmptyComposition = await invokeCompositionResult(
        {
          type: "composition",
          matchedRoute: "contextual-editing",
          compositionApiResponse: {
            composition: {
              ...EMPTY_COMPOSITION,
              _id: contextualEditingCompositionId != null ? contextualEditingCompositionId : EMPTY_COMPOSITION._id
            }
          }
        },
        0
      );
      return previewEmptyComposition;
    } else {
      try {
        if (!silent) {
          console.log("Fetch route", nodePath);
        }
        const time = Date.now();
        const response = await routeClient.getRoute({
          ...requestOptions,
          projectMapId,
          path: nodePath
        });
        const duration = Date.now() - time;
        if (!silent) {
          logRouteResponse(response, duration);
        }
        if (response.type === "redirect") {
          return invokeRedirectResult(response, duration);
        }
        if (response.type === "notFound") {
          return invokeNotFoundResult(response, duration);
        }
        const handleResult = await invokeCompositionResult(response, duration);
        if (!handleResult) {
          return invokeNotFoundResult({ type: "notFound" }, duration);
        }
        return handleResult;
      } catch (e) {
        console.error(red("Failed to fetch route"), e);
        if (e instanceof ApiClientError) {
          if (e.statusCode === 404) {
            return invokeNotFoundResult({ type: "notFound" }, 0);
          }
          throw new Error(`Failed to fetch route. See preceding server logs for details.`);
        }
        throw e;
      }
    }
  };
}

// src/route/withUniformGetServerSideProps.ts
var unstable_withUniformGetServerSideProps = (options) => {
  const defaultHandleRedirect = (requestUrl, matched) => {
    return {
      redirect: {
        destination: RedirectClient.getTargetVariableExpandedUrl(requestUrl, matched.redirect),
        statusCode: matched.redirect.targetStatusCode
      }
    };
  };
  const defaultHandleNotFound = () => ({
    notFound: true
  });
  const defaultHandleComposition = async (matched) => {
    return {
      props: {
        data: matched.compositionApiResponse.composition
      }
    };
  };
  const routeFetcher = createRouteFetcher({
    ...options,
    defaultHandleComposition,
    defaultHandleNotFound,
    defaultHandleRedirect,
    parseContext(context) {
      var _a;
      return {
        contextualEditingCompositionId: (_a = context.previewData) == null ? void 0 : _a.compositionId,
        resolvedUrl: context.resolvedUrl
      };
    }
  });
  return routeFetcher;
};

// src/route/withUniformGetStaticProps.ts
import { RedirectClient as RedirectClient2 } from "@uniformdev/redirect";
var unstable_withUniformGetStaticProps = (options) => {
  const defaultHandleRedirect = (requestUrl, matched) => {
    return {
      redirect: {
        destination: RedirectClient2.getTargetVariableExpandedUrl(requestUrl, matched.redirect),
        statusCode: matched.redirect.targetStatusCode
      }
    };
  };
  const defaultHandleNotFound = () => ({
    notFound: true
  });
  const defaultHandleComposition = async (matched) => {
    return {
      props: {
        data: matched.compositionApiResponse.composition
      }
    };
  };
  const routeFetcher = createRouteFetcher({
    ...options,
    defaultHandleComposition,
    defaultHandleNotFound,
    defaultHandleRedirect,
    parseContext(context) {
      var _a, _b;
      return {
        contextualEditingCompositionId: (_a = context.previewData) == null ? void 0 : _a.compositionId,
        resolvedUrl: resolveSlugFromParams({
          params: context.params,
          param: (_b = options == null ? void 0 : options.param) != null ? _b : "route"
        })
      };
    }
  });
  return routeFetcher;
};

// src/route/index.ts
var unstable_getServerSideProps = unstable_withUniformGetServerSideProps();
var unstable_getStaticProps = unstable_withUniformGetStaticProps();
var getStaticPaths = withUniformGetStaticPaths();
export {
  getStaticPaths,
  unstable_getServerSideProps,
  unstable_getStaticProps,
  unstable_withUniformGetServerSideProps,
  unstable_withUniformGetStaticProps,
  withUniformGetStaticPaths
};
