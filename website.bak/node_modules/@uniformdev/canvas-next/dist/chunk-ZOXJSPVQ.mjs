import {
  resolveSlugFromParams
} from "./chunk-TR7V6ABJ.mjs";

// src/project-map/withUniformGetServerSideProps.ts
import {
  CANVAS_DRAFT_STATE,
  CANVAS_PUBLISHED_STATE,
  CanvasClient,
  EMPTY_COMPOSITION,
  logCompositionResponse
} from "@uniformdev/canvas";
var withUniformGetServerSideProps = (options) => {
  const canvasClient = (options == null ? void 0 : options.client) || new CanvasClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    apiHost: process.env.UNIFORM_CLI_BASE_URL,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  return async function wrappedGetServerSideProps(context) {
    var _a, _b;
    const projectMapId = (_a = options == null ? void 0 : options.projectMapId) != null ? _a : process.env.UNIFORM_PROJECT_MAP_ID;
    const { preview, previewData } = context;
    let composition = void 0;
    let nodePath = (options == null ? void 0 : options.prefix) ? context.resolvedUrl.replace(new RegExp(`^${options.prefix}`), "") : context.resolvedUrl;
    if (options == null ? void 0 : options.modifyPath) {
      nodePath = options.modifyPath(nodePath, context);
    }
    if (previewData == null ? void 0 : previewData.isUniformContextualEditing) {
      composition = { ...EMPTY_COMPOSITION, _id: (_b = previewData.compositionId) != null ? _b : EMPTY_COMPOSITION._id };
    } else {
      try {
        const time = Date.now();
        const response = await canvasClient.getCompositionByNodePath({
          ...options == null ? void 0 : options.requestOptions,
          projectMapId,
          projectMapNodePath: nodePath,
          state: preview || (options == null ? void 0 : options.preview) ? CANVAS_DRAFT_STATE : CANVAS_PUBLISHED_STATE
        });
        const duration = Date.now() - time;
        composition = response.composition;
        if (!(options == null ? void 0 : options.silent)) {
          logCompositionResponse(response, duration);
        }
      } catch (e) {
        console.error("[canvas-next] Failed to fetch composition", e);
        return {
          notFound: true
        };
      }
    }
    const ret = (options == null ? void 0 : options.callback) ? await options.callback(context, composition) : { props: {} };
    if (Object.hasOwn(ret, "props")) {
      const casted = ret;
      casted.props["data"] = composition;
    }
    return ret;
  };
};

// src/project-map/withUniformGetStaticPaths.ts
import { CANVAS_DRAFT_STATE as CANVAS_DRAFT_STATE2, CANVAS_PUBLISHED_STATE as CANVAS_PUBLISHED_STATE2 } from "@uniformdev/canvas";
import {
  ProjectMapClient
} from "@uniformdev/project-map";
var withUniformGetStaticPaths = (options) => {
  return async function wrappedGetStaticPaths() {
    var _a, _b;
    const projectMapId = (_a = options == null ? void 0 : options.projectMapId) != null ? _a : process.env.UNIFORM_PROJECT_MAP_ID;
    const projectMapClient = (_b = options == null ? void 0 : options.client) != null ? _b : new ProjectMapClient({
      apiKey: process.env.UNIFORM_API_KEY,
      projectId: process.env.UNIFORM_PROJECT_ID,
      apiHost: process.env.UNIFORM_CLI_BASE_URL
    });
    const response = await projectMapClient.getNodes({
      ...options == null ? void 0 : options.requestOptions,
      path: options == null ? void 0 : options.rootPath,
      projectMapId,
      state: (options == null ? void 0 : options.preview) ? CANVAS_DRAFT_STATE2 : CANVAS_PUBLISHED_STATE2
    });
    const nodes = (options == null ? void 0 : options.callback) ? await options.callback(response.nodes) : response.nodes;
    const paths = nodes == null ? void 0 : nodes.filter((node) => Boolean(node.compositionId)).map((node) => {
      var _a2;
      return `${(_a2 = options == null ? void 0 : options.prefix) != null ? _a2 : ""}${node.path}`;
    });
    return {
      paths,
      fallback: true
    };
  };
};

// src/project-map/withUniformGetStaticProps.ts
import {
  CANVAS_DRAFT_STATE as CANVAS_DRAFT_STATE3,
  CANVAS_PUBLISHED_STATE as CANVAS_PUBLISHED_STATE3,
  CanvasClient as CanvasClient2,
  EMPTY_COMPOSITION as EMPTY_COMPOSITION2,
  logCompositionResponse as logCompositionResponse2
} from "@uniformdev/canvas";
var withUniformGetStaticProps = (options) => {
  var _a;
  const canvasClient = (_a = options == null ? void 0 : options.client) != null ? _a : new CanvasClient2({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    apiHost: process.env.UNIFORM_CLI_BASE_URL,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  return async function wrappedGetStaticProps(context) {
    var _a2, _b;
    const projectMapId = (_a2 = options == null ? void 0 : options.projectMapId) != null ? _a2 : process.env.UNIFORM_PROJECT_MAP_ID;
    let pathString = resolveSlugFromParams({
      param: options == null ? void 0 : options.param,
      params: context == null ? void 0 : context.params
    });
    if (options == null ? void 0 : options.modifyPath) {
      pathString = options.modifyPath(pathString, context);
    }
    const { preview, previewData } = context;
    let composition = void 0;
    if (previewData == null ? void 0 : previewData.isUniformContextualEditing) {
      composition = { ...EMPTY_COMPOSITION2, _id: (_b = previewData.compositionId) != null ? _b : EMPTY_COMPOSITION2._id };
    } else {
      try {
        const time = Date.now();
        const response = await canvasClient.getCompositionByNodePath({
          ...options == null ? void 0 : options.requestOptions,
          projectMapId,
          projectMapNodePath: pathString,
          state: preview || (options == null ? void 0 : options.preview) ? CANVAS_DRAFT_STATE3 : CANVAS_PUBLISHED_STATE3
        });
        const duration = Date.now() - time;
        composition = response.composition;
        if (!(options == null ? void 0 : options.silent)) {
          logCompositionResponse2(response, duration);
        }
      } catch (e) {
        console.error("[canvas-next] Failed to fetch composition", e);
        return {
          notFound: true
        };
      }
    }
    const ret = options.callback ? await options.callback(context, composition) : { props: {} };
    if (composition && Object.hasOwn(ret, "props")) {
      const casted = ret;
      casted.props["data"] = composition;
    }
    return ret;
  };
};

// src/project-map/index.ts
var getServerSideProps = withUniformGetServerSideProps();
var getStaticProps = withUniformGetStaticProps({ param: "path" });
var getStaticPaths = withUniformGetStaticPaths();

export {
  withUniformGetServerSideProps,
  withUniformGetStaticPaths,
  withUniformGetStaticProps,
  getServerSideProps,
  getStaticProps,
  getStaticPaths
};
