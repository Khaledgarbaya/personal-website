"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/project-map/index.ts
var project_map_exports = {};
__export(project_map_exports, {
  getServerSideProps: () => getServerSideProps,
  getStaticPaths: () => getStaticPaths,
  getStaticProps: () => getStaticProps,
  withUniformGetServerSideProps: () => withUniformGetServerSideProps,
  withUniformGetStaticPaths: () => withUniformGetStaticPaths,
  withUniformGetStaticProps: () => withUniformGetStaticProps
});
module.exports = __toCommonJS(project_map_exports);

// src/project-map/withUniformGetServerSideProps.ts
var import_canvas = require("@uniformdev/canvas");
var withUniformGetServerSideProps = (options) => {
  const canvasClient = (options == null ? void 0 : options.client) || new import_canvas.CanvasClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    apiHost: process.env.UNIFORM_CLI_BASE_URL,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  return async function wrappedGetServerSideProps(context) {
    var _a, _b;
    const projectMapId = (_a = options == null ? void 0 : options.projectMapId) != null ? _a : process.env.UNIFORM_PROJECT_MAP_ID;
    const { preview, previewData } = context;
    let composition = void 0;
    let nodePath = (options == null ? void 0 : options.prefix) ? context.resolvedUrl.replace(new RegExp(`^${options.prefix}`), "") : context.resolvedUrl;
    if (options == null ? void 0 : options.modifyPath) {
      nodePath = options.modifyPath(nodePath, context);
    }
    if (previewData == null ? void 0 : previewData.isUniformContextualEditing) {
      composition = { ...import_canvas.EMPTY_COMPOSITION, _id: (_b = previewData.compositionId) != null ? _b : import_canvas.EMPTY_COMPOSITION._id };
    } else {
      try {
        const time = Date.now();
        const response = await canvasClient.getCompositionByNodePath({
          ...options == null ? void 0 : options.requestOptions,
          projectMapId,
          projectMapNodePath: nodePath,
          state: preview || (options == null ? void 0 : options.preview) ? import_canvas.CANVAS_DRAFT_STATE : import_canvas.CANVAS_PUBLISHED_STATE
        });
        const duration = Date.now() - time;
        composition = response.composition;
        if (!(options == null ? void 0 : options.silent)) {
          (0, import_canvas.logCompositionResponse)(response, duration);
        }
      } catch (e) {
        console.error("[canvas-next] Failed to fetch composition", e);
        return {
          notFound: true
        };
      }
    }
    const ret = (options == null ? void 0 : options.callback) ? await options.callback(context, composition) : { props: {} };
    if (Object.hasOwn(ret, "props")) {
      const casted = ret;
      casted.props["data"] = composition;
    }
    return ret;
  };
};

// src/project-map/withUniformGetStaticPaths.ts
var import_canvas2 = require("@uniformdev/canvas");
var import_project_map = require("@uniformdev/project-map");
var withUniformGetStaticPaths = (options) => {
  return async function wrappedGetStaticPaths() {
    var _a, _b;
    const projectMapId = (_a = options == null ? void 0 : options.projectMapId) != null ? _a : process.env.UNIFORM_PROJECT_MAP_ID;
    const projectMapClient = (_b = options == null ? void 0 : options.client) != null ? _b : new import_project_map.ProjectMapClient({
      apiKey: process.env.UNIFORM_API_KEY,
      projectId: process.env.UNIFORM_PROJECT_ID,
      apiHost: process.env.UNIFORM_CLI_BASE_URL
    });
    const response = await projectMapClient.getNodes({
      ...options == null ? void 0 : options.requestOptions,
      path: options == null ? void 0 : options.rootPath,
      projectMapId,
      state: (options == null ? void 0 : options.preview) ? import_canvas2.CANVAS_DRAFT_STATE : import_canvas2.CANVAS_PUBLISHED_STATE
    });
    const nodes = (options == null ? void 0 : options.callback) ? await options.callback(response.nodes) : response.nodes;
    const paths = nodes == null ? void 0 : nodes.filter((node) => Boolean(node.compositionId)).map((node) => {
      var _a2;
      return `${(_a2 = options == null ? void 0 : options.prefix) != null ? _a2 : ""}${node.path}`;
    });
    return {
      paths,
      fallback: true
    };
  };
};

// src/project-map/withUniformGetStaticProps.ts
var import_canvas3 = require("@uniformdev/canvas");

// src/helpers/resolveSlugFromParams.ts
var resolveSlugFromParams = ({
  param = "slug",
  params
}) => {
  const slug = (params == null ? void 0 : params[param]) || "";
  const slugString = Array.isArray(slug) ? slug.join("/") : slug;
  return `/${slugString}`;
};

// src/project-map/withUniformGetStaticProps.ts
var withUniformGetStaticProps = (options) => {
  var _a;
  const canvasClient = (_a = options == null ? void 0 : options.client) != null ? _a : new import_canvas3.CanvasClient({
    apiKey: process.env.UNIFORM_API_KEY,
    projectId: process.env.UNIFORM_PROJECT_ID,
    apiHost: process.env.UNIFORM_CLI_BASE_URL,
    edgeApiHost: process.env.UNIFORM_CLI_BASE_EDGE_URL
  });
  return async function wrappedGetStaticProps(context) {
    var _a2, _b;
    const projectMapId = (_a2 = options == null ? void 0 : options.projectMapId) != null ? _a2 : process.env.UNIFORM_PROJECT_MAP_ID;
    let pathString = resolveSlugFromParams({
      param: options == null ? void 0 : options.param,
      params: context == null ? void 0 : context.params
    });
    if (options == null ? void 0 : options.modifyPath) {
      pathString = options.modifyPath(pathString, context);
    }
    const { preview, previewData } = context;
    let composition = void 0;
    if (previewData == null ? void 0 : previewData.isUniformContextualEditing) {
      composition = { ...import_canvas3.EMPTY_COMPOSITION, _id: (_b = previewData.compositionId) != null ? _b : import_canvas3.EMPTY_COMPOSITION._id };
    } else {
      try {
        const time = Date.now();
        const response = await canvasClient.getCompositionByNodePath({
          ...options == null ? void 0 : options.requestOptions,
          projectMapId,
          projectMapNodePath: pathString,
          state: preview || (options == null ? void 0 : options.preview) ? import_canvas3.CANVAS_DRAFT_STATE : import_canvas3.CANVAS_PUBLISHED_STATE
        });
        const duration = Date.now() - time;
        composition = response.composition;
        if (!(options == null ? void 0 : options.silent)) {
          (0, import_canvas3.logCompositionResponse)(response, duration);
        }
      } catch (e) {
        console.error("[canvas-next] Failed to fetch composition", e);
        return {
          notFound: true
        };
      }
    }
    const ret = options.callback ? await options.callback(context, composition) : { props: {} };
    if (composition && Object.hasOwn(ret, "props")) {
      const casted = ret;
      casted.props["data"] = composition;
    }
    return ret;
  };
};

// src/project-map/index.ts
var getServerSideProps = withUniformGetServerSideProps();
var getStaticProps = withUniformGetStaticProps({ param: "path" });
var getStaticPaths = withUniformGetStaticPaths();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getServerSideProps,
  getStaticPaths,
  getStaticProps,
  withUniformGetServerSideProps,
  withUniformGetStaticPaths,
  withUniformGetStaticProps
});
