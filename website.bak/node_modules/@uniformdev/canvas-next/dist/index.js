"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createPreviewHandler: () => createPreviewHandler,
  createPreviewHandlerGet: () => createPreviewHandlerGet,
  createPreviewHandlerPost: () => createPreviewHandlerPost,
  resolveSlugFromParams: () => resolveSlugFromParams
});
module.exports = __toCommonJS(src_exports);

// src/helpers/resolveSlugFromParams.ts
var resolveSlugFromParams = ({
  param = "slug",
  params
}) => {
  const slug = (params == null ? void 0 : params[param]) || "";
  const slugString = Array.isArray(slug) ? slug.join("/") : slug;
  return `/${slugString}`;
};

// src/preview/previewHandlerGet.ts
var import_canvas = require("@uniformdev/canvas");
var getQueryParam = (req, paramName) => {
  const value = req.query[paramName];
  if (typeof value === "undefined") {
    return void 0;
  }
  return Array.isArray(value) ? value[0] : value;
};
var createPreviewHandlerGet = ({ secret, resolveFullPath = resolveFullPathDefault } = {}) => async (req, res) => {
  if (req.headers["sec-fetch-mode"] === "no-cors") {
    return res.status(204).end();
  }
  const queryParamsToPreserve = [import_canvas.IN_CONTEXT_EDITOR_QUERY_STRING_PARAM];
  const id = getQueryParam(req, "id");
  const slug = getQueryParam(req, "slug");
  const path = getQueryParam(req, "path");
  const locale = getQueryParam(req, "locale");
  const pathToRedirectTo = resolveFullPath({ id, slug, path, locale });
  validateLocalRedirectUrl(pathToRedirectTo);
  if (!pathToRedirectTo) {
    return res.status(400).json({ message: "Could not resolve the full path of the preview page" });
  }
  if (req.query.disable) {
    res.clearPreviewData();
    res.redirect(pathToRedirectTo);
    return;
  }
  const previewSecret = typeof secret === "function" ? secret == null ? void 0 : secret() : secret;
  const isUsingPreviewSecret = Boolean(previewSecret);
  if (isUsingPreviewSecret && req.query.secret !== previewSecret) {
    return res.status(401).json({ message: "Invalid token" });
  }
  const isUniformContextualEditing = req.query[import_canvas.IN_CONTEXT_EDITOR_QUERY_STRING_PARAM] === "true";
  res.setPreviewData(
    {
      isUniformContextualEditing,
      compositionId: id,
      compositionSlug: slug,
      compositionPath: path,
      locale
    },
    {
      // By default the preview cookies stays as long as the tab is open. And in contextual editing mode, people tend to open Canvas editor (one tab) and another tab to see published changes.
      // This causes the second tab to still have the preview cookie, which causes unexpected behavior.
      // This is more obvious in contextual editing mode because we skip the composition fetching and the user sees a blank page where they expected the published composition.
      // We set this value to `10` just to handle the case of middlewares and redirections, ideally `0` should do the trick.
      maxAge: isUniformContextualEditing ? 10 : void 0
    }
  );
  const cookies = res.getHeader("Set-Cookie");
  res.setHeader(
    "Set-Cookie",
    cookies == null ? void 0 : cookies.map((cookie) => cookie.replace("SameSite=Lax", "SameSite=None;Secure"))
  );
  const newQuery = new URLSearchParams();
  queryParamsToPreserve.forEach((param) => {
    const paramValue = req.query[param];
    if (typeof paramValue === "string") {
      newQuery.append(param, paramValue);
    }
  });
  const urlToRedirectTo = newQuery.toString() ? `${pathToRedirectTo}?${newQuery.toString()}` : pathToRedirectTo;
  res.redirect(urlToRedirectTo);
};
var resolveFullPathDefault = ({ slug, path }) => {
  return path || slug;
};
function validateLocalRedirectUrl(pathToRedirectTo) {
  if (pathToRedirectTo == null ? void 0 : pathToRedirectTo.match(/^[a-z]+:\/\//g)) {
    throw new Error("Tried to redirect to absolute URL with protocol. Disallowing open redirect.");
  }
}

// src/preview/previewHandlerPost.ts
var import_canvas2 = require("@uniformdev/canvas");
var createPreviewHandlerPost = ({ secret, enhance } = {}) => async (req, res) => {
  const { composition, hash } = req.body;
  if (!composition) {
    return res.status(422).json({ message: 'Missing "composition" parameter' });
  }
  const previewSecret = typeof secret === "function" ? secret == null ? void 0 : secret() : secret;
  const hasProvidedHash = Boolean(hash);
  const hasConfiguredHash = Boolean(previewSecret);
  if (hasProvidedHash && hasConfiguredHash) {
    const calculatedHash = (0, import_canvas2.generateHash)({
      composition,
      secret: previewSecret
    });
    if (calculatedHash !== hash) {
      return res.status(401).json({ message: "Not authorized" });
    }
  } else if (hasConfiguredHash) {
    return res.status(401).json({ message: "Not authorized" });
  }
  await (enhance == null ? void 0 : enhance(composition, {
    req
  }));
  return res.status(200).json({
    composition
  });
};

// src/preview/previewHandler.ts
var createPreviewHandler = ({ secret, enhance, resolveFullPath } = {}) => async (req, res) => {
  var _a;
  const method = (_a = req.method) == null ? void 0 : _a.toLocaleLowerCase();
  if (method === "get") {
    return createPreviewHandlerGet({ secret, resolveFullPath })(req, res);
  } else if (method === "post") {
    return createPreviewHandlerPost({ secret, enhance })(req, res);
  } else if (method === "options") {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Origin, Content-Type, Accept");
    res.setHeader("Access-Control-Allow-Methods", "GET");
    return res.status(204);
  }
  return res.status(501).json({ message: `Method "${method}" not implemented` });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createPreviewHandler,
  createPreviewHandlerGet,
  createPreviewHandlerPost,
  resolveSlugFromParams
});
