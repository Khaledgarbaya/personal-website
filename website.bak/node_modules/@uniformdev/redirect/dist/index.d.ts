import { ClientOptions, ApiClient } from '@uniformdev/context/api';

interface pathTrieReturn<T> {
    data: T;
    variables: {
        key: string;
        value: string;
    }[];
}
declare class PathTrie<T> {
    constructor(initialData?: PathTrieData<T>);
    map: PathTrieData<T[]>;
    convertManyInsert<P>(data: P[], key: (data: P) => string, value?: (data: P) => T): void;
    insertMany(data: T[], key: (data: T) => string): void;
    insert(path: string, data: T): void;
    find(path: string, bestMatch?: boolean): pathTrieReturn<T>[] | undefined;
    private splitUrl;
}
declare class PathTrieData<T> {
    [key: string]: PathTrieData<T> | T;
}

declare class Trie<T> {
    constructor(initialData?: TrieData<T>);
    map: TrieData<T[]>;
    convertManyInsert<P>(data: P[], key: (data: P) => string, value?: (data: P) => T): void;
    insertMany(data: T[], key: (data: T) => string): void;
    insert(word: string, data: T): void;
    find(word: string, bestMatch?: boolean): {
        data: T;
        variables: string[];
    }[] | undefined;
    processChar(char: string): string;
}
declare class TrieData<T> {
    [key: string]: TrieData<T> | T;
}

type RedirectClientCacheOptions = {
    prePopulate?: boolean;
    refreshRate?: number;
};
declare abstract class RedirectClientCache<RedirectClientCacheOptions> {
    options: RedirectClientCacheOptions;
    constructor(options: RedirectClientCacheOptions);
    abstract get(key: string): Promise<PathTrie<RedirectDefinition>> | undefined;
    abstract set(key: string, data: Promise<PathTrie<RedirectDefinition>>, refresh: () => Promise<PathTrie<RedirectDefinition>>): void;
    abstract refresh(): Promise<void[]>;
}

type RedirectClientOptions = ClientOptions & {
    /** Caching mechanism used to hold redirect data payload for rapid retrieval */
    dataCache?: RedirectClientCache<RedirectClientCacheOptions>;
};
type RedirectOptions = {
    /** Reverse flips the direction of the search, instead of redirecting a source to a target you will be finding the source that could have produced a given target  */
    reverse?: boolean;
    /** Includes a label highlighting all wildcard variables with HTML em tags */
    label?: boolean;
};
declare class RedirectClient extends ApiClient<RedirectClientOptions> {
    constructor(options: RedirectClientOptions);
    getRedirect: (options: RedirectClientGetRedirect) => Promise<RedirectDefinition | undefined>;
    getRedirects: (options?: RedirectClientGetRedirects) => Promise<RedirectGetResponse>;
    getRedirectTrie: (options?: {
        reverse?: boolean;
        bypassDataCache?: boolean;
    }) => Promise<PathTrie<RedirectDefinition>>;
    resetRedirectTrieDataCache: () => Promise<void>;
    upsertRedirect: (redirect: RedirectUpsertRequest['redirect']) => Promise<string>;
    deleteRedirect: (id: string) => Promise<string>;
    static processUrlBestMatch: (url: string, trie: PathTrie<RedirectDefinition>, options?: RedirectOptions) => Promise<RedirectResult | undefined>;
    processUrlBestMatch: (url: string, options?: RedirectOptions) => Promise<RedirectResult | undefined>;
    processUrlAllMatches: (url: string, options?: RedirectOptions) => Promise<RedirectResult[]>;
    private assembleTrie;
    private static processHops;
    private static processHop;
    /**
     * Taking the url, found definition and variables and returning a redirect result object
     * @param processedUrl - Propertly formatted url input
     * @param definition - Redirect definition found to match the processed url
     * @param variables - Wildcard variables found during definition discovery
     * @param options - Different options available to the redirect engine
     */
    private static processDefinitionToResults;
    static getTargetVariableExpandedUrl(url: string, redirectDefinition: RedirectDefinition['redirect'], isVariable?: (pathSegment: string) => boolean): string;
    private static mergeQueryStrings;
    private static getSourceVariables;
    private static processUrl;
}
declare class UncachedRedirectClient extends RedirectClient {
    constructor(options: Omit<RedirectClientOptions, 'bypassCache'>);
}

/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */
interface paths {
    "/api/v1/redirect": {
        /** Called to retrieve a list of redirects related to a project */
        get: {
            parameters: {
                query: {
                    /** The project to fetch redirects for */
                    projectId: string;
                    /** Id of the redirect to retrieve */
                    id?: string;
                    /** Ids of the redirects to retrieve */
                    ids?: string[];
                    /** Source url to attempt to find redirects for */
                    sourceUrl?: string;
                    /** Id of the project map the source or target belongs to. */
                    projectMapId?: string;
                    /** Id of the project map node to find redirects for. */
                    sourceProjectMapNodeId?: string;
                    /** Id of the project map node to find redirects for. */
                    targetProjectMapNodeId?: string;
                    /** Column to order results by, only applicable if trie is not active. */
                    orderBy?: "updated_at asc" | "updated_at desc" | "source_url asc" | "source_url desc" | "target_url asc" | "target_url desc" | "created_by asc" | "created_by desc";
                    /** Limit the results to this number of results, ignored if using trie parameter. */
                    limit?: number;
                    /** Offset the results a certain amount, useful for pagination. */
                    offset?: number;
                    /** Search text to filter redirects by, filtering on the source and target urls */
                    search?: string;
                };
            };
            responses: {
                /** OK */
                200: {
                    content: {
                        "application/json": {
                            redirects: components["schemas"]["RedirectGetResponse"];
                            total?: number;
                            resultUrl?: string;
                        };
                    };
                };
                400: external["swagger.yml"]["components"]["responses"]["BadRequestError"];
                401: external["swagger.yml"]["components"]["responses"]["UnauthorizedError"];
                403: external["swagger.yml"]["components"]["responses"]["ForbiddenError"];
                429: external["swagger.yml"]["components"]["responses"]["RateLimitError"];
                500: external["swagger.yml"]["components"]["responses"]["InternalServerError"];
            };
        };
        put: {
            responses: {
                /** OK */
                200: {
                    content: {
                        "application/json": {
                            /**
                             * Format: uuid
                             * @description Id of the redirect
                             */
                            id: string;
                        };
                    };
                };
                /** OK */
                204: never;
                400: external["swagger.yml"]["components"]["responses"]["BadRequestError"];
                401: external["swagger.yml"]["components"]["responses"]["UnauthorizedError"];
                403: external["swagger.yml"]["components"]["responses"]["ForbiddenError"];
                429: external["swagger.yml"]["components"]["responses"]["RateLimitError"];
                500: external["swagger.yml"]["components"]["responses"]["InternalServerError"];
            };
            requestBody: {
                content: {
                    "application/json": {
                        /** @description Redirect object to insert */
                        redirect: components["schemas"]["Redirect"];
                        /**
                         * Format: uuid
                         * @description Project id to insert the redirect into
                         */
                        projectId: string;
                    };
                };
            };
        };
        /** Called to delete a redirect */
        delete: {
            responses: {
                /** OK */
                200: {
                    content: {
                        "application/json": {
                            /**
                             * Format: uuid
                             * @description Id of the redirect
                             */
                            id: string;
                        };
                    };
                };
                /** OK */
                204: never;
                400: external["swagger.yml"]["components"]["responses"]["BadRequestError"];
                401: external["swagger.yml"]["components"]["responses"]["UnauthorizedError"];
                403: external["swagger.yml"]["components"]["responses"]["ForbiddenError"];
                429: external["swagger.yml"]["components"]["responses"]["RateLimitError"];
                500: external["swagger.yml"]["components"]["responses"]["InternalServerError"];
            };
            requestBody: {
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description Redirect id to be deleted.
                         */
                        id: string;
                        /**
                         * Format: uuid
                         * @description Project the redirect belongs to.
                         */
                        projectId: string;
                    };
                };
            };
        };
        /** Handles preflight requests. This endpoint allows CORS. */
        options: {
            responses: {
                /** OK */
                204: never;
            };
        };
    };
}
interface components {
    schemas: {
        RedirectGetResponse: {
            redirect: components["schemas"]["Redirect"];
            metadata: components["schemas"]["RedirectMetadata"];
        }[];
        RedirectMetadata: {
            /** @description The last time the redirect was modified in UTC */
            updatedAt?: string;
            /** @description The last user who modified this redirect */
            updatedBy?: string;
            /** @description The time the redirect was created in UTC */
            createdAt?: string;
            /** @description The user who created this redirect or system */
            createdBy?: string;
        };
        Redirect: {
            /**
             * Format: uuid
             * @description Id of the redirect.
             */
            id?: string;
            /** @description Source meant to match a url that needs to be redirected. */
            sourceUrl: string;
            /** @description Target meant to be redirected to. */
            targetUrl: string;
            /** @description Redirect type to occur from this redirect. */
            targetStatusCode: number;
            /**
             * Format: uuid
             * @description Project map node related to the source this redirect.
             */
            sourceProjectMapNodeId?: string;
            /**
             * Format: uuid
             * @description Project map node related to the target this redirect.
             */
            targetProjectMapNodeId?: string;
            /**
             * Format: uuid
             * @description Project map related to this redirect.
             */
            projectMapId?: string;
            /** @description Signals the redirect engine to retain query string parameters to the target url. */
            sourceRetainQuerystring?: boolean;
            /** @description Incoming requests must match the domain that's defined in the redirection source. */
            sourceMustMatchDomain?: boolean;
            /** @description Rewritten url should match the protocol (http / https) of the incoming request instead of whatever is defined in the redirection target. */
            targetPreserveIncomingProtocol?: boolean;
            /** @description Rewritten url should match the domain of the incoming request regardless of what is defined in the redirection target. */
            targetPreserveIncomingDomain?: boolean;
            /** @description Stop running rules after this redirect rule gets executed. */
            stopExecutingAfter?: boolean;
            /** @description Merge incoming querystring with the querystring defined on the redirection target, taking the incoming querystring parameter where a merge is not possible. */
            targetMergeQuerystring?: boolean;
            /** @description Label as system generated or user generated. */
            labelAsSystem?: boolean;
        };
    };
}
interface external {
    "swagger.yml": {
        paths: {};
        components: {
            schemas: {
                Error: {
                    /** @description Error message(s) that occurred while processing the request */
                    errorMessage?: string[] | string;
                };
            };
            responses: {
                /** Request input validation failed */
                BadRequestError: {
                    content: {
                        "application/json": external["swagger.yml"]["components"]["schemas"]["Error"];
                    };
                };
                /** API key or token was not valid */
                UnauthorizedError: {
                    content: {
                        "application/json": external["swagger.yml"]["components"]["schemas"]["Error"];
                    };
                };
                /** Permission was denied */
                ForbiddenError: {
                    content: {
                        "application/json": external["swagger.yml"]["components"]["schemas"]["Error"];
                    };
                };
                /** Resource not found */
                NotFoundError: {
                    content: {
                        "application/json": external["swagger.yml"]["components"]["schemas"]["Error"];
                    };
                };
                /** Too many requests in allowed time period */
                RateLimitError: unknown;
                /** Execution error occurred */
                InternalServerError: unknown;
            };
        };
        operations: {};
    };
}

type RedirectUpsertRequest = paths['/api/v1/redirect']['put']['requestBody']['content']['application/json'];
type RedirectDeleteRequest = paths['/api/v1/redirect']['delete']['requestBody']['content']['application/json'];
type RedirectGetRequest = paths['/api/v1/redirect']['get']['parameters']['query'];
type RedirectUpsertResponse = paths['/api/v1/redirect']['put']['responses']['200']['content']['application/json'];
type RedirectDeleteResponse = paths['/api/v1/redirect']['delete']['responses']['200']['content']['application/json'];
type RedirectGetResponse = paths['/api/v1/redirect']['get']['responses']['200']['content']['application/json'];
type RedirectClientGetRequest = Omit<RedirectGetRequest, 'projectId'>;
type RedirectDefinition = RedirectGetResponse['redirects'][0];
type RedirectDefinitions = {
    redirects: RedirectDefinition['redirect'][];
};
type RedirectResult = {
    url: string;
    label?: string;
    headers?: {
        [key: string]: string;
    };
    definition?: RedirectDefinition;
    lastHop?: RedirectResult;
};
type RedirectDataCache = {
    get: (client: RedirectClient) => Promise<Trie<RedirectDefinition>>;
    preload?: boolean;
};
type RedirectClientGetRedirect = Pick<RedirectClientGetRequest, 'id' | 'projectMapId' | 'sourceProjectMapNodeId' | 'targetProjectMapNodeId'>;
type RedirectClientGetRedirects = Pick<RedirectClientGetRequest, 'ids' | 'limit' | 'offset' | 'orderBy' | 'search'>;

declare class WithMemoryCache extends RedirectClientCache<RedirectClientCacheOptions> {
    constructor(options: RedirectClientCacheOptions);
    private static trieCache;
    get(key: string): Promise<PathTrie<RedirectDefinition>> | undefined;
    set(key: string, data: Promise<PathTrie<RedirectDefinition>> | undefined, refresh: (() => Promise<PathTrie<RedirectDefinition>>) | undefined): void;
    refresh(): Promise<void[]>;
}

type Wildcard = {
    pathSegment: string;
    index: number;
};
type SourceAndTarget = {
    sourceUrl: string;
    targetUrl: string;
};
type SourceTargetAndWildcards = SourceAndTarget & {
    sourceWildcards: Wildcard[];
    targetWildcards: Wildcard[];
};
type RedirectFileConverterParams<T> = {
    client?: RedirectClient;
    redirectEntryObject: (redirect: RedirectDefinition) => T;
    wildcardConverter?: (sourceTarget: SourceTargetAndWildcards) => SourceAndTarget;
    writeFile: (redirects: T[]) => void;
};
declare function ExtractWildcards(url: string): Wildcard[];
declare function RedirectFileConverter<T>({ client, redirectEntryObject, wildcardConverter, writeFile, }: RedirectFileConverterParams<T>): Promise<void>;

export { ExtractWildcards, PathTrie, PathTrieData, RedirectClient, RedirectClientGetRedirect, RedirectClientGetRedirects, RedirectClientGetRequest, RedirectClientOptions, RedirectDataCache, RedirectDefinition, RedirectDefinitions, RedirectDeleteRequest, RedirectDeleteResponse, RedirectFileConverter, RedirectFileConverterParams, RedirectGetRequest, RedirectGetResponse, RedirectOptions, RedirectResult, RedirectUpsertRequest, RedirectUpsertResponse, SourceAndTarget, SourceTargetAndWildcards, UncachedRedirectClient, Wildcard, WithMemoryCache, pathTrieReturn };
