"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ProjectMapClient: () => ProjectMapClient,
  ROOT_NODE_PATH: () => ROOT_NODE_PATH,
  Route: () => Route,
  UncachedProjectMapClient: () => UncachedProjectMapClient
});
module.exports = __toCommonJS(src_exports);

// src/projectMapClient.ts
var import_api = require("@uniformdev/context/api");
var ROOT_NODE_PATH = "/";
var ProjectMapClient = class extends import_api.ApiClient {
  constructor(options) {
    super(options);
    this.getProjectMapDefinitions = async () => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/project-map", { projectId });
      return await this.apiClient(fetchUri);
    };
    this.getProjectMapDefinition = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/project-map", {
        ...options,
        projectId
      });
      return await this.apiClient(fetchUri);
    };
    this.upsertProjectMap = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/project-map");
      const result = await this.apiClient(fetchUri, {
        method: "PUT",
        body: JSON.stringify({ ...options, projectId })
      });
      return result.projectMapId;
    };
    this.deleteProjectMap = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/project-map");
      await this.apiClient(fetchUri, {
        method: "DELETE",
        body: JSON.stringify({ ...options, projectId }),
        expectNoContent: true
      });
    };
    this.upsertProjectMapNodes = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/project-map-nodes");
      await this.apiClient(fetchUri, {
        method: "PUT",
        body: JSON.stringify({
          ...options,
          projectId,
          nodes: options.nodes.map((n) => {
            return {
              ...n,
              node: { ...this.cleanProjectMapNode(n.node) }
            };
          })
        }),
        expectNoContent: true
      });
    };
    this.deleteProjectMapNode = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/project-map-nodes");
      if (!options.path) {
        await this.apiClient(fetchUri, {
          method: "DELETE",
          body: JSON.stringify({
            ...options,
            projectId
          }),
          expectNoContent: true
        });
      }
    };
    this.getSubtree = async (options) => {
      var _a;
      const fetchOptions = this.setFetchOptions(options);
      fetchOptions["tree"] = "true";
      const fetchUri = this.createUrl("/api/v1/project-map-nodes", fetchOptions);
      const result = await this.apiClient(fetchUri);
      const root = {
        ...result.tree
      };
      const nodes = [root];
      while (nodes && nodes.length > 0) {
        const currentNode = nodes.pop();
        let lastChild = void 0;
        (_a = currentNode == null ? void 0 : currentNode.children) == null ? void 0 : _a.forEach((child) => {
          child.parent = cutReferences(currentNode);
          child.previousSibling = cutReferences(lastChild);
          if (lastChild) {
            lastChild.nextSibling = cutReferences(child);
          }
          lastChild = child;
          nodes.push(child);
        });
      }
      return root;
    };
    this.getNodes = async (options) => {
      const fetchOptions = this.setFetchOptions(options);
      const fetchUri = this.createUrl("/api/v1/project-map-nodes", fetchOptions);
      return await this.apiClient(fetchUri);
    };
  }
  setFetchOptions(options) {
    const { projectId } = this.options;
    const fetchOptions = {
      projectId
    };
    Object.entries(options).forEach(([key, value]) => {
      if (value === void 0) {
        return;
      }
      if (typeof value === "boolean") {
        if (!value) {
          return;
        }
        fetchOptions[key] = "true";
        return;
      }
      if (typeof value === "number") {
        fetchOptions[key] = value.toString(10);
        return;
      }
      fetchOptions[key] = value;
    });
    return fetchOptions;
  }
  cleanProjectMapNode(node) {
    var _a, _b, _c;
    return {
      id: ((_c = (_b = (_a = node.id) == null ? void 0 : _a.match(/^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i)) == null ? void 0 : _b.length) != null ? _c : 0) == 1 ? node.id : void 0,
      path: node.path,
      name: node.name,
      type: node.type,
      order: node.order,
      data: node.data,
      compositionId: node.compositionId,
      description: node.description
    };
  }
};
var UncachedProjectMapClient = class extends ProjectMapClient {
  constructor(options) {
    super({ ...options, bypassCache: true });
  }
};
var cutReferences = (node) => node ? {
  ...node,
  parent: void 0,
  children: void 0
} : void 0;

// src/util/Route.ts
var _routeInfo, _parseRouteOrPath, parseRouteOrPath_fn, _isDynamicRouteSegment, isDynamicRouteSegment_fn;
var _Route = class {
  constructor(route) {
    this.route = route;
    __privateAdd(this, _routeInfo, void 0);
    var _a;
    __privateSet(this, _routeInfo, __privateMethod(_a = _Route, _parseRouteOrPath, parseRouteOrPath_fn).call(_a, this.route));
  }
  get dynamicSegmentCount() {
    return __privateGet(this, _routeInfo).segments.reduce(
      (count, segment) => {
        var _a;
        return __privateMethod(_a = _Route, _isDynamicRouteSegment, isDynamicRouteSegment_fn).call(_a, segment) ? count + 1 : count;
      },
      0
    );
  }
  /** Tests if an incoming path matches this route */
  matches(path) {
    var _a, _b;
    const { segments: pathSegments, queryParams: pathQuery } = __privateMethod(_a = _Route, _parseRouteOrPath, parseRouteOrPath_fn).call(_a, path);
    const { segments: routeSegments } = __privateGet(this, _routeInfo);
    if (pathSegments.length !== routeSegments.length) {
      return { match: false };
    }
    const possibleMatch = {
      match: true,
      dynamicSegmentCount: 0,
      pathParams: {},
      queryParams: {}
    };
    for (let i = 0; i < routeSegments.length; i++) {
      const routeSegment = routeSegments[i];
      const pathSegment = pathSegments[i];
      if (__privateMethod(_b = _Route, _isDynamicRouteSegment, isDynamicRouteSegment_fn).call(_b, routeSegment)) {
        const key = routeSegment.slice(1);
        possibleMatch.pathParams[key] = pathSegment;
        possibleMatch.dynamicSegmentCount++;
      } else if (routeSegment !== pathSegment) {
        return { match: false };
      }
    }
    for (const [key, value] of __privateGet(this, _routeInfo).queryParams) {
      possibleMatch.queryParams[key] = pathQuery.has(key) ? pathQuery.get(key) : value;
    }
    return possibleMatch;
  }
  /**
   * Creates an expanded path value for this route given dynamic input values and allowed query string values
   */
  expand(options) {
    const { dynamicInputValues = {}, allowedQueryParams = [] } = options != null ? options : {};
    const path = __privateGet(this, _routeInfo).segments.map((segment) => {
      const dynamicSegmentName = _Route.getDynamicRouteSegmentName(segment);
      if (!dynamicSegmentName) {
        return segment;
      }
      const dynamicSegmentValue = dynamicInputValues[dynamicSegmentName];
      if (!dynamicSegmentValue) {
        console.warn(
          "Missing dynamic input value for",
          dynamicSegmentName,
          "in",
          this.route,
          "using literal value"
        );
        return segment;
      }
      return encodeURIComponent(dynamicSegmentValue);
    }).join("/");
    const queries = allowedQueryParams.filter((qs) => typeof dynamicInputValues[qs] === "string").map((qs) => `${encodeURIComponent(qs)}=${encodeURIComponent(dynamicInputValues[qs])}`);
    const query = queries.length ? `?${queries.join("&")}` : "";
    return `/${path}${query}`;
  }
  static getDynamicRouteSegmentName(segment) {
    var _a;
    if (!__privateMethod(_a = _Route, _isDynamicRouteSegment, isDynamicRouteSegment_fn).call(_a, segment)) {
      return void 0;
    }
    return segment.slice(_Route.dynamicSegmentPrefix.length);
  }
};
var Route = _Route;
_routeInfo = new WeakMap();
_parseRouteOrPath = new WeakSet();
parseRouteOrPath_fn = function(path) {
  if (!path.startsWith("/") || path === "") {
    throw new Error(`Path must start with a slash: ${path}`);
  }
  const pathSegments = path.substring(1).split("/");
  const [lastSegmentWithoutQuery, queryString] = pathSegments[pathSegments.length - 1].split("?");
  pathSegments[pathSegments.length - 1] = lastSegmentWithoutQuery;
  const queryParams = new URLSearchParams(queryString);
  return { segments: pathSegments, queryParams };
};
_isDynamicRouteSegment = new WeakSet();
isDynamicRouteSegment_fn = function(segment) {
  return segment.startsWith(_Route.dynamicSegmentPrefix);
};
__privateAdd(Route, _parseRouteOrPath);
__privateAdd(Route, _isDynamicRouteSegment);
Route.dynamicSegmentPrefix = ":";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ProjectMapClient,
  ROOT_NODE_PATH,
  Route,
  UncachedProjectMapClient
});
