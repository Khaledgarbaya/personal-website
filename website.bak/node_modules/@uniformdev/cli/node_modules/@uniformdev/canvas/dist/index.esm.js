var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self = this;
      this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// src/CanvasClient.ts
import { ApiClient } from "@uniformdev/context/api";

// ../../node_modules/.pnpm/p-retry@5.1.2/node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2(), 1);
var networkErrorMsgs = /* @__PURE__ */ new Set([
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed",
  // `cross-fetch`
  "fetch failed"
  // Undici (Node.js)
]);
var AbortError = class extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
var isNetworkError = (errorMessage) => networkErrorMsgs.has(errorMessage);
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new Error(errorMessage) : new DOMException(errorMessage);
async function pRetry(input, options) {
  return new Promise((resolve, reject) => {
    options = {
      onFailedAttempt() {
      },
      retries: 10,
      ...options
    };
    const operation = import_retry.default.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options);
          try {
            await options.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", () => {
        operation.stop();
        const reason = options.signal.reason === void 0 ? getDOMException("The operation was aborted.") : options.signal.reason;
        reject(reason instanceof Error ? reason : getDOMException(reason));
      }, {
        once: true
      });
    }
  });
}

// ../../node_modules/.pnpm/p-throttle@5.0.0/node_modules/p-throttle/index.js
var AbortError2 = class extends Error {
  constructor() {
    super("Throttled function aborted");
    this.name = "AbortError";
  }
};
function pThrottle({ limit, interval, strict }) {
  if (!Number.isFinite(limit)) {
    throw new TypeError("Expected `limit` to be a finite number");
  }
  if (!Number.isFinite(interval)) {
    throw new TypeError("Expected `interval` to be a finite number");
  }
  const queue = /* @__PURE__ */ new Map();
  let currentTick = 0;
  let activeCount = 0;
  function windowedDelay() {
    const now = Date.now();
    if (now - currentTick > interval) {
      activeCount = 1;
      currentTick = now;
      return 0;
    }
    if (activeCount < limit) {
      activeCount++;
    } else {
      currentTick += interval;
      activeCount = 1;
    }
    return currentTick - now;
  }
  const strictTicks = [];
  function strictDelay() {
    const now = Date.now();
    if (strictTicks.length < limit) {
      strictTicks.push(now);
      return 0;
    }
    const earliestTime = strictTicks.shift() + interval;
    if (now >= earliestTime) {
      strictTicks.push(now);
      return 0;
    }
    strictTicks.push(earliestTime);
    return earliestTime - now;
  }
  const getDelay = strict ? strictDelay : windowedDelay;
  return (function_) => {
    const throttled = function(...args) {
      if (!throttled.isEnabled) {
        return (async () => function_.apply(this, args))();
      }
      let timeout;
      return new Promise((resolve, reject) => {
        const execute = () => {
          resolve(function_.apply(this, args));
          queue.delete(timeout);
        };
        timeout = setTimeout(execute, getDelay());
        queue.set(timeout, reject);
      });
    };
    throttled.abort = () => {
      for (const timeout of queue.keys()) {
        clearTimeout(timeout);
        queue.get(timeout)(new AbortError2());
      }
      queue.clear();
      strictTicks.splice(0, strictTicks.length);
    };
    throttled.isEnabled = true;
    return throttled;
  };
}

// src/enhancement/createLimitPolicy.ts
function createLimitPolicy({
  throttle = { interval: 1e3, limit: 10 },
  retry: retry2 = { retries: 1, factor: 1.66 }
}) {
  const throttler = throttle ? pThrottle(throttle) : null;
  return function limitPolicy(func) {
    let currentFunc = async () => await func();
    if (throttler) {
      const throttleFunc = currentFunc;
      currentFunc = throttler(throttleFunc);
    }
    if (retry2) {
      const retryFunc = currentFunc;
      currentFunc = () => pRetry(retryFunc, retry2);
    }
    return currentFunc();
  };
}
var nullLimitPolicy = async (func) => await func();

// src/CanvasClient.ts
var CANVAS_URL = "/api/v1/canvas";
var CanvasClient = class extends ApiClient {
  constructor(options) {
    var _a;
    if (!options.limitPolicy) {
      options.limitPolicy = createLimitPolicy({});
    }
    super(options);
    this.edgeApiHost = (_a = options.edgeApiHost) != null ? _a : "https://uniform.global";
  }
  /** Fetches lists of Canvas compositions, optionally by type */
  async getCompositionList(options) {
    const { projectId } = this.options;
    const fetchUri = this.createUrl(CANVAS_URL, { ...options, projectId });
    return await this.apiClient(fetchUri);
  }
  getCompositionByNodePath(options) {
    return this.getOneComposition(options);
  }
  getCompositionByNodeId(options) {
    return this.getOneComposition(options);
  }
  getCompositionBySlug(options) {
    return this.getOneComposition(options);
  }
  getCompositionById(options) {
    return this.getOneComposition(options);
  }
  getOneComposition({
    skipDataResolution,
    diagnostics,
    ...params
  }) {
    const { projectId } = this.options;
    if (skipDataResolution) {
      return this.apiClient(this.createUrl(CANVAS_URL, { ...params, projectId }));
    }
    const edgeParams = {
      ...params,
      projectId,
      ...diagnostics ? { diagnostics: "true" } : {}
    };
    const edgeUrl = this.createUrl("/api/v1/composition", edgeParams, this.edgeApiHost);
    return this.apiClient(edgeUrl);
  }
  /** Updates or creates a Canvas component definition */
  async updateComposition(body) {
    const fetchUri = this.createUrl(CANVAS_URL);
    await this.apiClient(fetchUri, {
      method: "PUT",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
  /** Deletes a Canvas component definition */
  async removeComposition(body) {
    const fetchUri = this.createUrl(CANVAS_URL);
    const { projectId } = this.options;
    await this.apiClient(fetchUri, {
      method: "DELETE",
      body: JSON.stringify({ ...body, projectId }),
      expectNoContent: true
    });
  }
  /** Fetches all Canvas component definitions */
  async getComponentDefinitions(options) {
    const { projectId } = this.options;
    const fetchUri = this.createUrl("/api/v1/canvas-definitions", { ...options, projectId });
    return await this.apiClient(fetchUri);
  }
  /** Updates or creates a Canvas component definition */
  async updateComponentDefinition(body) {
    const fetchUri = this.createUrl("/api/v1/canvas-definitions");
    await this.apiClient(fetchUri, {
      method: "PUT",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
  /** Deletes a Canvas component definition */
  async removeComponentDefinition(body) {
    const fetchUri = this.createUrl("/api/v1/canvas-definitions");
    await this.apiClient(fetchUri, {
      method: "DELETE",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
};
var UncachedCanvasClient = class extends CanvasClient {
  constructor(options) {
    super({ ...options, bypassCache: true });
  }
};

// src/CompositionRelationshipClient.ts
import { ApiClient as ApiClient2 } from "@uniformdev/context/api";
var COMPOSITION_RELATIONSHIP_URL = "/api/v1/composition-relationships";
var unstable_CompositionRelationshipClient = class extends ApiClient2 {
  constructor(options) {
    super(options);
    this.getDefinitionsRelationships = async ({
      definitionIds,
      withCompositions
    }) => {
      const url = this.createUrl(COMPOSITION_RELATIONSHIP_URL, {
        type: "definition",
        projectId: this._options.projectId,
        definitionIds: definitionIds.join(","),
        withCompositions
      });
      return this.apiClient(url);
    };
    this.clearAllRelationships = async () => {
      const url = this.createUrl(COMPOSITION_RELATIONSHIP_URL);
      return this.apiClient(url, {
        method: "POST",
        body: JSON.stringify({
          type: "clear",
          projectId: this._options.projectId
        })
      });
    };
    this.indexCompositionRelationships = async ({
      state,
      compositionId
    }) => {
      const url = this.createUrl(COMPOSITION_RELATIONSHIP_URL);
      return this.apiClient(url, {
        method: "POST",
        body: JSON.stringify({
          type: "index",
          projectId: this._options.projectId,
          state,
          compositionId
        })
      });
    };
    this.getVersion = async () => {
      const url = this.createUrl("/api/v1/usage-tracking", {
        projectId: this._options.projectId
      });
      return this.apiClient(url).then((response) => response.version);
    };
    this.setVersion = async (version) => {
      const url = this.createUrl("/api/v1/usage-tracking");
      return this.apiClient(url, {
        method: "POST",
        body: JSON.stringify({
          projectId: this._options.projectId,
          version
        })
      });
    };
    this._options = options;
  }
};

// src/DataSourceClient.ts
import { ApiClient as ApiClient3 } from "@uniformdev/context/api";
var dataSourceUrl = "/api/v1/data-source";
var dataSourcesUrl = "/api/v1/data-sources";
var DataSourceClient = class extends ApiClient3 {
  constructor(options) {
    super(options);
  }
  /** Fetches all DataSources for a project */
  async get(options) {
    const { projectId } = this.options;
    const fetchUri = this.createUrl(dataSourceUrl, { ...options, projectId });
    return await this.apiClient(fetchUri);
  }
  /** Fetches all DataSources for a project */
  async getList(options) {
    const { projectId } = this.options;
    const fetchUri = this.createUrl(dataSourcesUrl, { ...options, projectId });
    return await this.apiClient(fetchUri);
  }
  /** Updates or creates (based on id) a DataSource */
  async upsert(body) {
    const fetchUri = this.createUrl(dataSourceUrl);
    await this.apiClient(fetchUri, {
      method: "PUT",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
  /** Deletes a DataSource */
  async remove(body) {
    const fetchUri = this.createUrl(dataSourceUrl);
    await this.apiClient(fetchUri, {
      method: "DELETE",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
};

// src/DataTypeClient.ts
import { ApiClient as ApiClient4 } from "@uniformdev/context/api";
var _url;
var _DataTypeClient = class extends ApiClient4 {
  constructor(options) {
    super(options);
  }
  /** Fetches all DataTypes for a project */
  async get(options) {
    const { projectId } = this.options;
    const fetchUri = this.createUrl(__privateGet(_DataTypeClient, _url), { ...options, projectId });
    return await this.apiClient(fetchUri);
  }
  /** Updates or creates (based on id) a DataType */
  async upsert(body) {
    const fetchUri = this.createUrl(__privateGet(_DataTypeClient, _url));
    await this.apiClient(fetchUri, {
      method: "PUT",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
  /** Deletes a DataType */
  async remove(body) {
    const fetchUri = this.createUrl(__privateGet(_DataTypeClient, _url));
    await this.apiClient(fetchUri, {
      method: "DELETE",
      body: JSON.stringify({ ...body, projectId: this.options.projectId }),
      expectNoContent: true
    });
  }
};
var DataTypeClient = _DataTypeClient;
_url = new WeakMap();
__privateAdd(DataTypeClient, _url, "/api/v1/data-types");

// src/enhancement/batchEnhancer.ts
var BatchEntry = class {
  constructor(_resolve, _reject, args) {
    this._resolve = _resolve;
    this._reject = _reject;
    this.args = args;
    this._isCompleted = false;
  }
  /** Mark the batch entry as successfully completed. */
  resolve(result) {
    this._resolve(result);
    this._isCompleted = true;
  }
  /** Mark the batch entry as failed. */
  reject(reason) {
    this._reject(reason);
    this._isCompleted = true;
  }
  /** @return Whether the batch entry has been completed (resolved or rejected). */
  get isCompleted() {
    return this._isCompleted;
  }
};
function createBatchEnhancer({
  handleBatch,
  shouldQueue,
  limitPolicy
}) {
  let queue = [];
  const batchedFn = async (options) => {
    if (!shouldQueue || shouldQueue(options)) {
      return new Promise((resolve, reject) => {
        queue.push(new BatchEntry(resolve, reject, options));
      });
    } else {
      return void 0;
    }
  };
  const complete = async () => {
    if (queue.length > 0) {
      try {
        await handleBatch(queue);
      } catch (e) {
        queue.forEach((entry) => entry.reject(e));
      }
      if (queue.some((entry) => !entry.isCompleted)) {
        throw new Error("The completeAll() function failed to resolve or reject all promises in the batch!");
      }
    }
    const processed = queue.length;
    queue = [];
    return processed;
  };
  return { enhanceOne: batchedFn, completeAll: complete, limitPolicy };
}

// src/enhancement/compose.ts
var compose = (input, ...composers) => {
  const composed = {
    enhanceOne: (value) => {
      let result = "enhanceOne" in input ? input.enhanceOne(value) : input(value);
      for (const currentComposed of composers) {
        const current = isPromise(result) ? result : Promise.resolve(result);
        const enhanceOne = "enhanceOne" in currentComposed ? currentComposed.enhanceOne : currentComposed;
        result = current.then(
          (res) => enhanceOne({
            ...value,
            parameter: {
              type: value.parameter.type,
              value: res
            }
          })
        );
      }
      return result;
    },
    completeAll: async () => {
      var _a, _b;
      for (const currentComposed of composers) {
        if ("completeAll" in currentComposed) {
          throw new Error(
            "Only the first enhancer in a compose chain can use the completeAll function (batching)"
          );
        }
      }
      return (_b = "completeAll" in input ? (_a = input.completeAll) == null ? void 0 : _a.call(input) : 0) != null ? _b : 0;
    }
  };
  return composed;
};
function isPromise(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}

// src/enhancement/walkComponentTree.ts
function walkComponentTree(component, visitor, initialContext) {
  var _a;
  const componentQueue = [
    {
      ancestorsAndSelf: [{ component, parentSlot: void 0, parentSlotIndex: void 0 }],
      context: initialContext
    }
  ];
  const childContexts = /* @__PURE__ */ new Map();
  do {
    const currentQueueEntry = componentQueue.pop();
    if (!currentQueueEntry)
      continue;
    const currentComponent = currentQueueEntry.ancestorsAndSelf[0];
    let visitDescendants = true;
    let descendantContext = (_a = childContexts.get(currentComponent.component)) != null ? _a : currentQueueEntry.context;
    visitor(
      currentComponent.component,
      currentQueueEntry.ancestorsAndSelf,
      {
        replaceComponent: (replacementComponent) => {
          Object.assign(currentComponent.component, replacementComponent);
          const propertiesToCheck = [
            "parameters",
            "variant",
            "slots",
            "data",
            "_pattern",
            "_patternError"
          ];
          propertiesToCheck.forEach((property) => {
            if (!replacementComponent[property]) {
              delete currentComponent.component[property];
            }
          });
        },
        removeComponent: () => {
          const { parentSlot, parentSlotIndex } = currentQueueEntry.ancestorsAndSelf[0];
          const parentComponent = currentQueueEntry.ancestorsAndSelf[1];
          if (parentSlot && typeof parentSlotIndex !== "undefined") {
            parentComponent.component.slots[parentSlot].splice(parentSlotIndex, 1);
          } else {
            throw new Error("Unable to delete composition.");
          }
        },
        insertAfter: (components) => {
          const componentsToInsert = Array.isArray(components) ? components : [components];
          const { parentSlot, parentSlotIndex } = currentQueueEntry.ancestorsAndSelf[0];
          const parentComponent = currentQueueEntry.ancestorsAndSelf[1];
          if (parentSlot && typeof parentSlotIndex !== "undefined") {
            parentComponent.component.slots[parentSlot].splice(
              parentSlotIndex + 1,
              0,
              ...componentsToInsert
            );
            componentQueue.unshift(
              ...componentsToInsert.map((enqueueingComponent) => ({
                ancestorsAndSelf: [
                  {
                    component: enqueueingComponent,
                    parentSlot,
                    get parentSlotIndex() {
                      return parentComponent.component.slots[parentSlot].findIndex(
                        (x) => x === enqueueingComponent
                      );
                    }
                  },
                  ...currentQueueEntry.ancestorsAndSelf
                ],
                context: descendantContext
              }))
            );
          } else {
            throw new Error("Unable to insert after a component not in a slot.");
          }
        },
        stopProcessingDescendants() {
          visitDescendants = false;
        },
        setDescendantsContext(context) {
          descendantContext = context;
        },
        setChildContext(child, context) {
          childContexts.set(child, context);
        }
      },
      descendantContext
    );
    const slots = currentComponent.component.slots;
    if (visitDescendants && slots) {
      const slotKeys = Object.keys(slots);
      for (let slotIndex = slotKeys.length - 1; slotIndex >= 0; slotIndex--) {
        const slotKey = slotKeys[slotIndex];
        const components = slots[slotKey];
        for (let componentIndex = components.length - 1; componentIndex >= 0; componentIndex--) {
          const enqueueingComponent = components[componentIndex];
          componentQueue.push({
            ancestorsAndSelf: [
              {
                component: enqueueingComponent,
                parentSlot: slotKey,
                get parentSlotIndex() {
                  return currentComponent.component.slots[slotKey].findIndex(
                    (x) => x === enqueueingComponent
                  );
                }
              },
              ...currentQueueEntry.ancestorsAndSelf
            ],
            context: descendantContext
          });
        }
      }
    }
  } while (componentQueue.length > 0);
}
function getComponentPath(ancestorsAndSelf) {
  const path = [];
  for (let i = ancestorsAndSelf.length - 1; i >= 0; i--) {
    const { parentSlot, parentSlotIndex } = ancestorsAndSelf[i];
    if (parentSlot && parentSlotIndex !== void 0) {
      path.push(`${parentSlot}[${parentSlotIndex}]`);
    }
  }
  return `.${path.join(".")}`;
}
function getComponentJsonPointer(ancestorsAndSelf, { withSlots = false } = {}) {
  const path = [];
  for (let i = ancestorsAndSelf.length - 1; i >= 0; i--) {
    const { parentSlot, parentSlotIndex } = ancestorsAndSelf[i];
    if (parentSlot && parentSlotIndex !== void 0) {
      path.push(`${parentSlot}/${parentSlotIndex}`);
    }
  }
  return withSlots ? `/slots/${path.join("/slots/")}` : `/${path.join("/")}`;
}

// src/enhancement/enhance.ts
async function enhance({
  composition,
  enhancers,
  context,
  onErrors = (errors) => {
    throw new Error(
      errors.map(
        (error) => `${error.message}
 ${typeof error.error === "object" && "stack" in error.error ? error.error.stack : error.error}`
      ).join("\n\n")
    );
  }
}) {
  const promises = [];
  const usedComponentEnhancers = /* @__PURE__ */ new Set();
  const usedParameterEnhancers = /* @__PURE__ */ new Set();
  walkComponentTree(composition, (currentComponent, componentContext) => {
    var _a;
    Object.entries((_a = currentComponent.parameters) != null ? _a : {}).forEach(([paramName, paramValue]) => {
      const enhancer = enhancers.resolveParameterEnhancer(currentComponent, paramName, paramValue);
      if (enhancer) {
        usedParameterEnhancers.add(enhancer);
        promises.push(
          enhanceParameter(currentComponent, componentContext, paramName, paramValue, enhancer, context)
        );
      }
    });
    const componentEnhancers = enhancers.resolveComponentEnhancers(currentComponent);
    promises.push(enhanceComponent(currentComponent, componentContext, componentEnhancers, context));
    usedComponentEnhancers.add(componentEnhancers);
  });
  promises.push(
    ...Array.from(usedComponentEnhancers).flatMap(
      (enhancerSet) => Array.from(enhancerSet).map(async ([, enhancer]) => {
        var _a;
        try {
          if (enhancer.completeAll) {
            const limitPolicy = (_a = enhancer.limitPolicy) != null ? _a : nullLimitPolicy;
            await limitPolicy(() => enhancer.completeAll());
          }
        } catch (error) {
          return {
            error,
            message: "Batch component enhancer failed. Individual failed components should receive their own rejections."
          };
        }
      })
    )
  );
  promises.push(
    ...Array.from(usedParameterEnhancers).map(async (enhancer) => {
      var _a;
      try {
        if (enhancer.completeAll) {
          const limitPolicy = (_a = enhancer.limitPolicy) != null ? _a : nullLimitPolicy;
          await limitPolicy(() => enhancer.completeAll());
        }
      } catch (error) {
        return {
          error,
          message: "Batch parameter enhancer failed. Individual failed parameters should receive their own rejections."
        };
      }
    })
  );
  const issues = (await Promise.all(promises)).flatMap((issue) => Array.isArray(issue) ? issue : [issue]).filter((issue) => issue);
  if (issues.length) {
    onErrors(issues);
  }
}
async function enhanceComponent(component, componentContext, enhancers, context) {
  if (enhancers.size) {
    component.data = {};
  }
  return await Promise.all(
    Array.from(enhancers).map(async ([enhancerName, enhancer]) => {
      var _a;
      try {
        const limitPolicy = enhancer.completeAll ? nullLimitPolicy : (_a = enhancer.limitPolicy) != null ? _a : nullLimitPolicy;
        const result = await limitPolicy(async () => enhancer.enhanceOne({ component, context }));
        if (result !== void 0 && result !== null) {
          component.data[enhancerName] = result;
        }
      } catch (error) {
        const message = `Component ${getComponentPath(componentContext)} (type: ${component.type}): data.${enhancerName} enhancer threw exception. Data key will not be present.`;
        delete component.data[enhancerName];
        return { message, error };
      }
    })
  );
}
async function enhanceParameter(component, componentContext, parameterName, parameter, enhancer, context) {
  var _a;
  try {
    const limitPolicy = enhancer.completeAll ? nullLimitPolicy : (_a = enhancer.limitPolicy) != null ? _a : nullLimitPolicy;
    const enhancedValue = await limitPolicy(
      async () => enhancer.enhanceOne({ parameter, parameterName, component, context })
    );
    if (enhancedValue === null) {
      delete component.parameters[parameterName];
    } else if (typeof enhancedValue === "undefined") {
      component.parameters[parameterName] = { ...parameter, value: parameter.value };
    } else {
      component.parameters[parameterName] = { ...parameter, value: enhancedValue };
    }
  } catch (error) {
    const message = `Component ${getComponentPath(componentContext)} (type: ${component.type}): enhancing parameter ${parameterName} (type: ${parameter.type}) threw exception. Parameter will be removed.`;
    delete component.parameters[parameterName];
    return { message, error };
  }
}

// src/enhancement/EnhancerBuilder.ts
var ChildEnhancerBuilder = class {
  constructor() {
    this._paramMatches = Array();
    this._dataMatches = /* @__PURE__ */ new Map();
  }
  /** Targets an enhancer to modify the value of any parameter */
  parameter(enhancer) {
    this._paramMatches.push({ enhancer: this._resolveParameterEnhancer(enhancer) });
    return this;
  }
  /** Targets an enhancer to modify the value of any parameter with a specific name */
  parameterName(name, enhancer) {
    const names = Array.isArray(name) ? name : [name];
    names.forEach(
      (name2) => this._paramMatches.push({ name: name2, enhancer: this._resolveParameterEnhancer(enhancer) })
    );
    return this;
  }
  /** Targets an enhancer to modify the value of any parameter with a specific type */
  parameterType(type, enhancer) {
    const types = Array.isArray(type) ? type : [type];
    types.forEach(
      (type2) => this._paramMatches.push({ type: type2, enhancer: this._resolveParameterEnhancer(enhancer) })
    );
    return this;
  }
  /**
   * Targets an enhancer to set a specific object key on the component's `data` property.
   * Note: an exception will be thrown if the same key is registered more than once.
   */
  data(name, enhancer) {
    if (this._dataMatches.has(name)) {
      throw new Error(`${name} enhancer data key has been used more than once. This will cause data loss.`);
    }
    this._dataMatches.set(name, typeof enhancer === "function" ? { enhanceOne: enhancer } : enhancer);
    return this;
  }
  /**
   * Resolves the parameter enhancer for a given parameter, if one exists.
   * The first matching enhancer by registration order is returned, if more than one could match.
   */
  resolveParameterEnhancer(parameterName, parameter) {
    var _a;
    return (_a = this._paramMatches.find(
      (m) => m.name && m.name === parameterName || m.type && m.type === parameter.type || !m.type && !m.name
    )) == null ? void 0 : _a.enhancer;
  }
  /**
   * Resolves component enhancer(s) for a given component.
   * Returns a Map where the key is the name of the data property and the value is the enhancer.
   */
  resolveComponentEnhancers() {
    return this._dataMatches;
  }
  _resolveParameterEnhancer(enhancer) {
    if (typeof enhancer === "function") {
      return { enhanceOne: enhancer };
    } else {
      return enhancer;
    }
  }
};
var EnhancerBuilder = class {
  constructor() {
    this._componentIndex = {};
    this._rootBuilder = new ChildEnhancerBuilder();
  }
  /** Targets an enhancer to modify the value of any parameter */
  parameter(enhancer) {
    this._rootBuilder.parameter(enhancer);
    return this;
  }
  /** Targets an enhancer to modify the value of any parameter with a specific name */
  parameterName(name, enhancer) {
    this._rootBuilder.parameterName(name, enhancer);
    return this;
  }
  /** Targets an enhancer to modify the value of any parameter with a specific type */
  parameterType(type, enhancer) {
    this._rootBuilder.parameterType(type, enhancer);
    return this;
  }
  /**
   * Targets an enhancer to set a specific object key on the component's `data` property.
   * Note: an exception will be thrown if the same key is registered more than once.
   */
  data(name, enhancer) {
    this._rootBuilder.data(name, enhancer);
    return this;
  }
  /**
   * Targets a subset of enhancers at a specific component type.
   * Global enhancers will still be run if no matching enhancer is registered for this component's properties.
   */
  component(name, builder) {
    const names = Array.isArray(name) ? name : [name];
    names.forEach((name2) => {
      this._componentIndex[name2] = this._componentIndex[name2] || new ChildEnhancerBuilder();
      builder(this._componentIndex[name2]);
    });
    return this;
  }
  /**
   * Resolves the parameter enhancer for a given parameter, if one exists.
   * The first matching enhancer by registration order is returned, if more than one could match.
   */
  resolveParameterEnhancer(component, parameterName, parameter) {
    const eb = this._componentIndex[component.type];
    if (eb) {
      const targetedResolver = eb.resolveParameterEnhancer(parameterName, parameter);
      if (targetedResolver) {
        return targetedResolver;
      }
    }
    return this._rootBuilder.resolveParameterEnhancer(parameterName, parameter);
  }
  /**
   * Resolves component enhancer(s) for a given component.
   * Returns a Map where the key is the name of the data property and the value is the enhancer.
   */
  resolveComponentEnhancers(component) {
    let componentEnhancers = this._rootBuilder.resolveComponentEnhancers();
    const eb = this._componentIndex[component.type];
    if (eb) {
      componentEnhancers = new Map(componentEnhancers);
      for (const [key, value] of eb.resolveComponentEnhancers()) {
        componentEnhancers.set(key, value);
      }
    }
    return componentEnhancers;
  }
};

// src/utils/constants.ts
var CANVAS_PERSONALIZE_TYPE = "$personalization";
var CANVAS_TEST_TYPE = "$test";
var CANVAS_LOCALIZATION_TYPE = "$localization";
var CANVAS_INTENT_TAG_PARAM = "intentTag";
var CANVAS_LOCALE_TAG_PARAM = "locale";
var CANVAS_PERSONALIZE_SLOT = "pz";
var CANVAS_TEST_SLOT = "test";
var CANVAS_LOCALIZATION_SLOT = "localized";
var CANVAS_DRAFT_STATE = 0;
var CANVAS_PUBLISHED_STATE = 64;
var CANVAS_PERSONALIZATION_PARAM = "$pzCrit";
var CANVAS_TEST_VARIANT_PARAM = "$tstVrnt";
var CANVAS_ENRICHMENT_TAG_PARAM = "$enr";
var IN_CONTEXT_EDITOR_QUERY_STRING_PARAM = "is_incontext_editing_mode";
var IN_CONTEXT_EDITOR_COMPONENT_START_ROLE = "uniform-component-start";
var IN_CONTEXT_EDITOR_COMPONENT_END_ROLE = "uniform-component-end";
var IN_CONTEXT_EDITOR_EMBED_SCRIPT_ID = "uniform-canvas-preview-script";
var IS_RENDERED_BY_UNIFORM_ATTRIBUTE = "data-is-rendered-by-uniform";
var PLACEHOLDER_ID = "placeholder";
var EMPTY_COMPOSITION = {
  _id: "_empty_composition_id",
  _name: "An empty composition used for contextual editing",
  type: "_empty_composition_type"
};
var EDGE_MIN_CACHE_TTL = 15;
var EDGE_MAX_CACHE_TTL = 600;
var EDGE_DEFAULT_CACHE_TTL = 30;
var EDGE_CACHE_DISABLED = -1;
var EDGE_MIN_L2_CACHE_TTL_IN_HOURS = 1;
var EDGE_MAX_L2_CACHE_TTL_IN_HOURS = 4 * 7 * 24;
var EDGE_DEFAULT_L2_CACHE_TTL_IN_HOURS = 24;

// src/enhancement/localize.ts
function extractLocales({ component }) {
  var _a;
  const variations = {};
  const slot = (_a = component.slots) == null ? void 0 : _a[CANVAS_LOCALIZATION_SLOT];
  slot == null ? void 0 : slot.forEach((slotComponent) => {
    var _a2;
    const localeParameter = (_a2 = slotComponent.parameters) == null ? void 0 : _a2[CANVAS_LOCALE_TAG_PARAM];
    if ((localeParameter == null ? void 0 : localeParameter.value) && typeof localeParameter.value === "string") {
      variations[localeParameter.value] = variations[localeParameter.value] || [];
      variations[localeParameter.value].push(slotComponent);
    }
  });
  return variations;
}
function localize({
  composition,
  locale
}) {
  walkComponentTree(composition, (currentComponent, _componentContext, actions) => {
    if (currentComponent.type === CANVAS_LOCALIZATION_TYPE) {
      const locales = extractLocales({ component: currentComponent });
      const resolvedLocale = typeof locale === "string" ? locale : locale({ component: currentComponent, locales });
      let replaceComponent;
      if (resolvedLocale) {
        replaceComponent = locales[resolvedLocale];
      }
      if (replaceComponent == null ? void 0 : replaceComponent.length) {
        const [first, ...rest] = replaceComponent;
        actions.replaceComponent(first);
        if (rest.length) {
          actions.insertAfter(rest);
        }
      } else {
        actions.removeComponent();
      }
    }
  });
}

// src/enhancement/UniqueBatchEntries.ts
var UniqueBatchEntries = class {
  constructor(entries, uniqueKeySelector) {
    this.groups = entries.reduce((acc, task) => {
      var _a;
      const key = uniqueKeySelector(task.args);
      acc[key] = (_a = acc[key]) != null ? _a : [];
      acc[key].push(task);
      return acc;
    }, {});
  }
  /** Resolves all entries in a group key with the same result value. */
  resolveKey(key, result) {
    this.groups[key].forEach((task) => task.resolve(result));
  }
  /** Resolves all remaining entries that have not been otherwise resolved with a specific value */
  resolveRemaining(value) {
    Object.keys(this.groups).forEach((key) => {
      this.groups[key].forEach((task) => {
        if (!task.isCompleted) {
          task.resolve(value);
        }
      });
    });
  }
};

// src/utils/hash.ts
var generateHash = ({
  composition,
  secret
}) => {
  if (!secret) {
    return void 0;
  }
  const str = `${JSON.stringify(composition)}-${secret}`;
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
};

// src/messaging/channel.ts
var isSelectComponentMessage = (message) => {
  return message.type === "select-component" && message.id !== void 0;
};
var isReadyMessage = (message) => {
  return message.type === "ready";
};
var isUpdateCompositionMessage = (message) => {
  return message.type === "update-composition";
};
var isUpdateCompositionInternalMessage = (message) => {
  return message.type === "update-composition-internal";
};
var isAddComponentMessage = (message) => {
  return message.type === "add-component";
};
var isMovingComponentMessage = (message) => {
  return message.type === "move-component";
};
var isUpdateComponentParameterMessage = (message) => {
  return message.type === "update-component-parameter";
};
var isDismissPlaceholderMessage = (message) => {
  return message.type === "dismiss-placeholder";
};
var isTriggerCompositionActionMessage = (message) => {
  return message.type === "trigger-composition-action";
};
var isUpdatePreviewSettingsMessage = (message) => {
  return message.type === "update-preview-settings";
};
var isReportRenderedCompositionsMessage = (message) => {
  return message.type === "report-rendered-compositions";
};
var createCanvasChannel = ({
  listenTo,
  broadcastTo
}) => {
  let handlerCounter = 0;
  const handlers = {};
  const broadcastToItems = [...broadcastTo];
  const postMessage = (message) => {
    broadcastToItems.forEach((item) => item.postMessage(JSON.stringify(message), "*"));
  };
  const selectComponent = (id) => {
    const message = {
      type: "select-component",
      id
    };
    postMessage(message);
  };
  const ready = () => {
    var _a, _b;
    if (typeof window === "undefined") {
      return;
    }
    const framework = (_a = window.__UNIFORM_CONTEXTUAL_EDITING__) == null ? void 0 : _a.framework;
    const version = (_b = window.__UNIFORM_CONTEXTUAL_EDITING__) == null ? void 0 : _b.version;
    const message = {
      type: "ready",
      framework,
      version
    };
    postMessage(message);
  };
  const on = (types, handler) => {
    const handlerId = ++handlerCounter;
    handlers[handlerId] = {
      types: Array.isArray(types) ? types : [types],
      handler
    };
    return () => {
      delete handlers[handlerId];
    };
  };
  const updateComposition = (composition, secret) => {
    const message = {
      type: "update-composition",
      composition,
      hash: generateHash({
        composition,
        secret
      })
    };
    postMessage(message);
  };
  const updateCompositionInternal = (composition, hash) => {
    const message = {
      type: "update-composition-internal",
      composition,
      hash
    };
    postMessage(message);
  };
  const addComponent = (options) => {
    const message = {
      ...options,
      type: "add-component"
    };
    postMessage(message);
  };
  const moveComponent = (options) => {
    const message = {
      ...options,
      type: "move-component"
    };
    postMessage(message);
  };
  const updateComponentParameter = (options) => {
    const message = {
      ...options,
      type: "update-component-parameter"
    };
    postMessage(message);
  };
  const dismissPlaceholder = (options) => {
    const message = {
      ...options,
      type: "dismiss-placeholder"
    };
    postMessage(message);
  };
  const triggerCompositionAction = (options) => {
    const message = {
      ...options,
      type: "trigger-composition-action"
    };
    postMessage(message);
  };
  const updatePreviewSettings = (options) => {
    const message = {
      ...options,
      type: "update-preview-settings"
    };
    postMessage(message);
  };
  const reportRenderedCompositions = (options) => {
    const message = {
      ...options,
      type: "report-rendered-compositions"
    };
    postMessage(message);
  };
  const messageEventListener = (event) => {
    if (typeof event.data !== "string") {
      return;
    }
    let message = null;
    try {
      const parsedMessage = JSON.parse(event.data);
      if (Object.hasOwn(parsedMessage, "type")) {
        message = parsedMessage;
      }
    } catch (e) {
    }
    if (!message) {
      return;
    }
    for (const handlerId in handlers) {
      const handler = handlers[handlerId];
      if (handler.types.includes(message.type)) {
        handler.handler(message, event);
      }
    }
  };
  listenTo.forEach((item) => item.addEventListener("message", messageEventListener));
  const destroy = () => {
    listenTo.forEach((item) => item.removeEventListener("message", messageEventListener));
  };
  return {
    ready,
    destroy,
    selectComponent,
    updateComposition,
    updateCompositionInternal,
    on,
    addComponent,
    moveComponent,
    updateComponentParameter,
    dismissPlaceholder,
    triggerCompositionAction,
    updatePreviewSettings,
    reportRenderedCompositions
  };
};

// src/preview/createEventBus.ts
var PUSHER_SRC = "https://js.pusher.com/7.0.3/pusher.min.js";
async function loadPusher() {
  if (typeof document === "undefined" || typeof window === "undefined") {
    return;
  }
  if (window.Pusher) {
    return window.Pusher;
  }
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      if (window.Pusher) {
        resolve(window.Pusher);
      }
      reject(
        `Unable to load pusher.js; Uniform Canvas live preview disabled. Consider adding <script src="${PUSHER_SRC}"></script> manually.`
      );
    }, 5e3);
    const pusher = document.createElement("script");
    pusher.src = PUSHER_SRC;
    pusher.addEventListener("load", () => {
      clearTimeout(timeout);
      resolve(window.Pusher);
    });
    document.head.appendChild(pusher);
  });
}
async function createEventBus() {
  const WindowPusher = await loadPusher();
  if (!WindowPusher) {
    return;
  }
  let bus = window.__UNIFORM_EVENT_BUS__;
  if (!bus) {
    const pusher = new WindowPusher("7b5f5abd160fea549ffe", {
      cluster: "mt1"
    });
    pusher.connect();
    console.log("[canvas] \u{1F525} preview connected");
    bus = window.__UNIFORM_EVENT_BUS__ = {
      subscribe: (channel) => {
        const channelObj = pusher.subscribe(channel);
        return {
          unsubscribe: () => pusher.unsubscribe(channel),
          addEventHandler: (eventName, handler) => {
            channelObj.bind(eventName, handler);
            return () => channelObj.unbind(eventName, handler);
          }
        };
      }
    };
  }
  return bus;
}

// src/preview/getChannelName.ts
function getChannelName(projectId, compositionId, state) {
  return `${projectId}.${compositionId}@${state}`;
}

// src/preview/subscribeToComposition.ts
function subscribeToComposition({
  projectId,
  compositionId,
  compositionState = 0,
  eventBus: { subscribe },
  callback,
  event = "updated"
}) {
  const channelName = getChannelName(projectId, compositionId, compositionState);
  const channel = subscribe(channelName);
  const off = channel.addEventHandler(event, callback);
  return () => {
    off();
    channel.unsubscribe();
  };
}

// src/RouteClient.ts
import { ApiClient as ApiClient5 } from "@uniformdev/context/api";
var ROUTE_URL = "/api/v1/route";
var unstable_RouteClient = class extends ApiClient5 {
  constructor(options) {
    var _a;
    if (!options.limitPolicy) {
      options.limitPolicy = createLimitPolicy({});
    }
    super(options);
    this.edgeApiHost = (_a = options.edgeApiHost) != null ? _a : "https://uniform.global";
  }
  /** Fetches lists of Canvas compositions, optionally by type */
  async getRoute(options) {
    const { projectId } = this.options;
    const fetchUri = this.createUrl(ROUTE_URL, { ...options, projectId }, this.edgeApiHost);
    return await this.apiClient(fetchUri);
  }
};

// src/utils/bindVariables.ts
function bindVariables({
  variables,
  value,
  errorPrefix = "Variable",
  handleBinding
}) {
  let boundCount = 0;
  const errors = [];
  const defaultHandleBinding = (variableName, variables2, errors2) => {
    const variableValue = variables2[variableName];
    if (variableValue === void 0) {
      errors2.push(`${errorPrefix} "${variableName}" is not defined`);
      return "";
    }
    return variableValue;
  };
  const result = value.replace(/(?<!\\)\${([^}]+)}/g, (_match, variableName) => {
    const variableValue = (handleBinding != null ? handleBinding : defaultHandleBinding)(variableName, variables, errors);
    boundCount++;
    return variableValue;
  });
  return { result, boundCount, errors: errors.length > 0 ? errors : void 0 };
}

// src/utils/bindVariablesToObject.ts
import { produce } from "immer";
function bindVariablesToObject(options) {
  return bindVariablesToObjectRecursive(options);
}
function bindVariablesToObjectRecursive({
  value,
  recursivePath,
  ...bindVariablesOptions
}) {
  let boundCount = 0;
  const errors = [];
  if (typeof value === "string") {
    return bindVariables({ ...bindVariablesOptions, value });
  }
  if (typeof value !== "object" || value === null) {
    return { boundCount: 0, result: value };
  }
  const result = produce(value, (draft) => {
    Object.entries(draft).forEach(([property, oldValue]) => {
      const currentObjectPath = recursivePath ? `${recursivePath}.${property}` : property;
      if (typeof oldValue === "string") {
        const bindResult = bindVariables({ ...bindVariablesOptions, value: oldValue });
        if (oldValue !== bindResult.result || bindResult.errors) {
          boundCount += bindResult.boundCount;
          draft[property] = bindResult.result;
          if (bindResult.errors) {
            errors.push(...bindResult.errors.map((e) => `${currentObjectPath}: ${e}`));
          }
        }
        return;
      }
      const childBind = bindVariablesToObject({
        ...bindVariablesOptions,
        value: oldValue,
        recursivePath: currentObjectPath
      });
      if (childBind.boundCount || childBind.errors) {
        boundCount += childBind.boundCount;
        draft[property] = childBind.result;
        if (childBind.errors) {
          errors.push(...childBind.errors.map((e) => `${currentObjectPath}: ${e}`));
        }
      }
    });
  });
  return { boundCount, result, errors: errors.length > 0 ? errors : void 0 };
}

// src/utils/createApiEnhancer.ts
var createUniformApiEnhancer = ({ apiUrl }) => {
  return async (message) => {
    const response = await fetch(apiUrl, {
      method: "post",
      body: JSON.stringify({
        composition: message.composition,
        hash: message.hash
      }),
      headers: {
        "Content-Type": "application/json"
      }
    });
    const json = await response.json();
    if (!response.ok) {
      throw new Error("Error reading enhanced composition");
    }
    const body = json;
    return body.composition;
  };
};

// src/utils/isSystemComponentDefinition.ts
var isSystemComponentDefinition = (componentType) => {
  return componentType.startsWith("$");
};

// src/utils/mapSlotToPersonalizedVariations.ts
function mapSlotToPersonalizedVariations(slot) {
  if (!slot)
    return [];
  return slot.map((v, i) => {
    var _a, _b;
    const contextTag = (_b = (_a = v.parameters) == null ? void 0 : _a[CANVAS_PERSONALIZATION_PARAM]) == null ? void 0 : _b.value;
    const id = (contextTag == null ? void 0 : contextTag.name) || `pz-${i}-${v.type}`;
    return {
      ...v,
      id,
      pz: contextTag
    };
  });
}

// src/utils/mapSlotToTestVariations.ts
function mapSlotToTestVariations(slot) {
  if (!slot)
    return [];
  return slot.map((v, i) => {
    var _a, _b, _c;
    const contextTag = (_b = (_a = v.parameters) == null ? void 0 : _a[CANVAS_TEST_VARIANT_PARAM]) == null ? void 0 : _b.value;
    const id = (_c = contextTag == null ? void 0 : contextTag.id) != null ? _c : "testId" in v ? v.testId : `ab-${i}-${v.type}`;
    return {
      ...v,
      id
      //testDistribution: contextTag?.testDistribution,
    };
  });
}

// src/index.ts
import { ApiClientError } from "@uniformdev/context/api";
var CanvasClientError = ApiClientError;
export {
  ApiClientError,
  BatchEntry,
  CANVAS_DRAFT_STATE,
  CANVAS_ENRICHMENT_TAG_PARAM,
  CANVAS_INTENT_TAG_PARAM,
  CANVAS_LOCALE_TAG_PARAM,
  CANVAS_LOCALIZATION_SLOT,
  CANVAS_LOCALIZATION_TYPE,
  CANVAS_PERSONALIZATION_PARAM,
  CANVAS_PERSONALIZE_SLOT,
  CANVAS_PERSONALIZE_TYPE,
  CANVAS_PUBLISHED_STATE,
  CANVAS_TEST_SLOT,
  CANVAS_TEST_TYPE,
  CANVAS_TEST_VARIANT_PARAM,
  CanvasClient,
  CanvasClientError,
  ChildEnhancerBuilder,
  DataSourceClient,
  DataTypeClient,
  EDGE_CACHE_DISABLED,
  EDGE_DEFAULT_CACHE_TTL,
  EDGE_DEFAULT_L2_CACHE_TTL_IN_HOURS,
  EDGE_MAX_CACHE_TTL,
  EDGE_MAX_L2_CACHE_TTL_IN_HOURS,
  EDGE_MIN_CACHE_TTL,
  EDGE_MIN_L2_CACHE_TTL_IN_HOURS,
  EMPTY_COMPOSITION,
  EnhancerBuilder,
  IN_CONTEXT_EDITOR_COMPONENT_END_ROLE,
  IN_CONTEXT_EDITOR_COMPONENT_START_ROLE,
  IN_CONTEXT_EDITOR_EMBED_SCRIPT_ID,
  IN_CONTEXT_EDITOR_QUERY_STRING_PARAM,
  IS_RENDERED_BY_UNIFORM_ATTRIBUTE,
  PLACEHOLDER_ID,
  UncachedCanvasClient,
  UniqueBatchEntries,
  bindVariables,
  bindVariablesToObject,
  compose,
  createBatchEnhancer,
  createCanvasChannel,
  createEventBus,
  createLimitPolicy,
  createUniformApiEnhancer,
  enhance,
  extractLocales,
  generateHash,
  getChannelName,
  getComponentJsonPointer,
  getComponentPath,
  isAddComponentMessage,
  isDismissPlaceholderMessage,
  isMovingComponentMessage,
  isReadyMessage,
  isReportRenderedCompositionsMessage,
  isSelectComponentMessage,
  isSystemComponentDefinition,
  isTriggerCompositionActionMessage,
  isUpdateComponentParameterMessage,
  isUpdateCompositionInternalMessage,
  isUpdateCompositionMessage,
  isUpdatePreviewSettingsMessage,
  localize,
  mapSlotToPersonalizedVariations,
  mapSlotToTestVariations,
  nullLimitPolicy,
  subscribeToComposition,
  unstable_CompositionRelationshipClient,
  unstable_RouteClient,
  walkComponentTree
};
