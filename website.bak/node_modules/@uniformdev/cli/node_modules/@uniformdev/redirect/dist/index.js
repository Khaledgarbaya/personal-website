"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.0.3",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          require: "./lib/main.js",
          types: "./lib/main.d.ts",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^17.0.9",
        decache: "^4.6.1",
        dtslint: "^3.7.0",
        sinon: "^12.0.1",
        standard: "^16.0.4",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.3.2",
        tap: "^15.1.6",
        tar: "^6.1.11",
        typescript: "^4.5.4"
      },
      engines: {
        node: ">=12"
      }
    };
  }
});

// ../../node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _log(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (options) {
        if (options.path != null) {
          dotenvPath = _resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else {
            if (override === true) {
              process.env[key] = parsed[key];
            }
            if (debug) {
              if (override === true) {
                _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
              } else {
                _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
              }
            }
          }
        });
        return { parsed };
      } catch (e) {
        if (debug) {
          _log(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    var DotenvModule = {
      config,
      parse
    };
    module2.exports.config = DotenvModule.config;
    module2.exports.parse = DotenvModule.parse;
    module2.exports = DotenvModule;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ExtractWildcards: () => ExtractWildcards,
  PathTrie: () => PathTrie,
  PathTrieData: () => PathTrieData,
  RedirectClient: () => RedirectClient,
  RedirectFileConverter: () => RedirectFileConverter,
  UncachedRedirectClient: () => UncachedRedirectClient,
  WithMemoryCache: () => WithMemoryCache
});
module.exports = __toCommonJS(src_exports);

// src/cache/redirectClientCache.ts
var RedirectClientCache = class {
  constructor(options) {
    this.options = options;
  }
};

// src/cache/withMemoryCache.ts
var _WithMemoryCache = class extends RedirectClientCache {
  constructor(options) {
    super(options);
  }
  /* Get data from the cache and debounce pausing refresh */
  get(key) {
    var _a, _b;
    return (_b = (_a = _WithMemoryCache.trieCache[key]) == null ? void 0 : _a.data) != null ? _b : void 0;
  }
  /* Set new data to the cache and reset the refresh method */
  set(key, data, refresh) {
    var _a;
    if (!data)
      return;
    const setCache = () => {
      _WithMemoryCache.trieCache[key] = {
        ..._WithMemoryCache.trieCache[key],
        data,
        refresh
      };
    };
    if (!((_a = _WithMemoryCache.trieCache[key]) == null ? void 0 : _a.data)) {
      setCache();
    } else {
      data.then(() => {
        setCache();
      });
    }
  }
  refresh() {
    var _a, _b;
    for (const key in _WithMemoryCache.trieCache) {
      const p = (_b = (_a = _WithMemoryCache.trieCache[key]) == null ? void 0 : _a.refresh) == null ? void 0 : _b.call(_a);
      if (p) {
        _WithMemoryCache.trieCache[key] = { ..._WithMemoryCache.trieCache[key], data: p };
      }
    }
    return Promise.all([]);
  }
};
var WithMemoryCache = _WithMemoryCache;
/* Memory static class level variable to store data across multiple instances of the redirect client */
WithMemoryCache.trieCache = {};

// src/data/pathTrie.ts
var import_rfdc = __toESM(require("rfdc"));
var dataProp = "~~data~~";
var PathTrie = class {
  constructor(initialData) {
    this.map = new PathTrieData();
    this.splitUrl = (url) => {
      if (url.startsWith("https://"))
        return ["https://", ...url.substring("https://".length).split("/")].filter((segment) => segment.length);
      if (url.startsWith("http://"))
        return ["http://", ...url.substring("http://".length).split("/")].filter((segment) => segment.length);
      return url.split("/").filter((segment) => segment.length);
    };
    this.clone = (0, import_rfdc.default)();
    if (initialData) {
      if (Object.hasOwn(initialData, "map")) {
        this.map = initialData.map;
      } else {
        this.map = initialData;
      }
    }
  }
  convertManyInsert(data, key, value) {
    data == null ? void 0 : data.forEach((d) => {
      if (value) {
        this.insert(key(d), value(d));
      } else {
        this.insert(key(d), d);
      }
    });
  }
  insertMany(data, key) {
    data.forEach((d) => {
      this.insert(key(d), d);
    });
  }
  insert(path, data) {
    let cur = this.map;
    const segments = this.splitUrl(path);
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === 0 && segment === "")
        continue;
      if (!Object.hasOwn(cur, segment)) {
        cur[segment] = new PathTrieData();
      }
      cur = cur[segment];
      if (i == segments.length - 1) {
        if (!cur[dataProp]) {
          cur[dataProp] = [];
        }
        cur[dataProp].push(data);
      }
    }
  }
  find(path, bestMatch = true) {
    let cur = this.clone(this.map);
    const segments = this.splitUrl(path);
    const wildcards = [];
    const ret = [];
    const splats = [];
    const processed = /* @__PURE__ */ new Set();
    const getVariables = () => {
      return wildcards.map((wildcard) => {
        if (wildcard.active)
          return { key: wildcard.name, value: segments[wildcard.start] };
        return void 0;
      }).filter((wildcard) => Boolean(wildcard));
    };
    const getPropsStartingWithColon = (obj) => {
      const result = [];
      for (const prop in obj) {
        if (prop.startsWith(":")) {
          result.push(prop);
        }
      }
      return result;
    };
    const scanWildcards = () => {
      let wildcard = void 0;
      while ((!wildcard || wildcard.active) && wildcards.length) {
        wildcard = wildcards.pop();
      }
      if (!wildcard || wildcard.active)
        return void 0;
      wildcard.active = true;
      cur = wildcard == null ? void 0 : wildcard.startTrie;
      wildcards.push(wildcard);
      return wildcard == null ? void 0 : wildcard.start;
    };
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (Object.hasOwn(cur, "*")) {
        cur["*"][dataProp].forEach((splat) => {
          splats.push({
            data: splat,
            variables: [...getVariables(), { key: ":splat", value: segments.slice(i).join("/") }]
          });
        });
      }
      getPropsStartingWithColon(cur).forEach((wildcard) => {
        if (!processed.has(wildcard)) {
          wildcards.push({
            startTrie: cur[wildcard],
            start: i,
            active: false,
            name: wildcard
          });
          processed.add(wildcard);
        }
      });
      if (Object.hasOwn(cur, segment)) {
        cur = cur[segment];
        if (i === segments.length - 1) {
          if (cur[dataProp]) {
            cur[dataProp].forEach((d) => ret.push({ data: d, variables: getVariables() }));
          }
        }
      } else if (i === segments.length - 1) {
        const more = scanWildcards();
        if (typeof more === "undefined")
          return [...ret, ...splats];
        i = more;
        if (i === segments.length - 1 && wildcards.length && wildcards[wildcards.length - 1].active && wildcards[wildcards.length - 1].startTrie[dataProp]) {
          wildcards[wildcards.length - 1].startTrie[dataProp].forEach(
            (d) => ret.push({ data: d, variables: getVariables() })
          );
        }
      } else {
        const more = scanWildcards();
        if (typeof more === "undefined")
          return [...ret, ...splats];
        i = more;
      }
      if (ret.length > 0 && bestMatch)
        return [...ret, ...splats];
    }
    return [...ret, ...splats];
  }
};
var PathTrieData = class {
};

// src/redirectClient.ts
var import_api = require("@uniformdev/context/api");
var _RedirectClient = class extends import_api.ApiClient {
  constructor(options) {
    super(options);
    this.getRedirect = async (options) => {
      var _a;
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/redirect", { ...options, projectId });
      const results = await this.apiClient(fetchUri);
      return (_a = results.redirects) == null ? void 0 : _a[0];
    };
    this.getRedirects = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/redirect", { ...options, projectId });
      const results = await this.apiClient(fetchUri);
      return results;
    };
    this.getRedirectTrie = async (options) => {
      var _a, _b;
      const { projectId } = this.options;
      const key = `${projectId}${(options == null ? void 0 : options.reverse) ? "r" : "f"}`;
      const cachePromise = (options == null ? void 0 : options.bypassDataCache) ? void 0 : (_a = this.options.dataCache) == null ? void 0 : _a.get(key);
      if (cachePromise) {
        const result = await cachePromise;
        if (result)
          return result;
      }
      const ret = this.assembleTrie(projectId, options);
      (_b = this.options.dataCache) == null ? void 0 : _b.set(key, ret, () => this.assembleTrie(projectId, options));
      return ret;
    };
    this.resetRedirectTrieDataCache = async () => {
      var _a;
      await ((_a = this.options.dataCache) == null ? void 0 : _a.refresh());
    };
    this.upsertRedirect = async (redirect) => {
      const {
        id,
        sourceUrl,
        targetStatusCode,
        targetUrl,
        labelAsSystem,
        projectMapId,
        sourceMustMatchDomain,
        sourceProjectMapNodeId,
        sourceRetainQuerystring,
        stopExecutingAfter,
        targetMergeQuerystring,
        targetPreserveIncomingDomain,
        targetPreserveIncomingProtocol,
        targetProjectMapNodeId
      } = redirect;
      const fetchUri = this.createUrl("/api/v1/redirect");
      const result = await this.apiClient(fetchUri, {
        method: "PUT",
        body: JSON.stringify({
          redirect: {
            id,
            sourceUrl,
            targetStatusCode,
            targetUrl,
            labelAsSystem,
            projectMapId,
            sourceMustMatchDomain,
            sourceProjectMapNodeId,
            sourceRetainQuerystring,
            stopExecutingAfter,
            targetMergeQuerystring,
            targetPreserveIncomingDomain,
            targetPreserveIncomingProtocol,
            targetProjectMapNodeId
          },
          projectId: this.options.projectId
        })
      });
      this.resetRedirectTrieDataCache();
      return result.id;
    };
    this.deleteRedirect = async (id) => {
      const fetchUri = this.createUrl("/api/v1/redirect");
      const result = await this.apiClient(fetchUri, {
        method: "DELETE",
        body: JSON.stringify({ id, projectId: this.options.projectId })
      });
      this.resetRedirectTrieDataCache();
      return result.id;
    };
    this.processUrlBestMatch = async (url, options) => {
      var _a;
      const trie = await this.getRedirectTrie({ reverse: Boolean(options == null ? void 0 : options.reverse) });
      return (_a = _RedirectClient.processHops(url, trie, true, options)) == null ? void 0 : _a[0];
    };
    this.processUrlAllMatches = async (url, options) => {
      const trie = await this.getRedirectTrie({ reverse: Boolean(options == null ? void 0 : options.reverse) });
      return _RedirectClient.processHops(url, trie, false, options);
    };
    if (options.dataCache && options.dataCache.options.prePopulate) {
      if (!options.dataCache.get(`${options.projectId}f`)) {
        options.dataCache.set(
          `${options.projectId}f`,
          this.getRedirectTrie(),
          () => this.getRedirectTrie({ bypassDataCache: true })
        );
      }
    }
  }
  async assembleTrie(projectId, options) {
    var _a;
    const trie = new PathTrie();
    let offset = 0;
    let total = 0;
    do {
      const fetchUri = this.createUrl("/api/v1/redirect", {
        projectId,
        limit: 50,
        offset
      });
      const redirects = await this.apiClient(fetchUri);
      trie.insertMany(
        redirects.redirects,
        (r) => (options == null ? void 0 : options.reverse) ? r.redirect.targetUrl : r.redirect.sourceUrl
      );
      total = (_a = redirects.total) != null ? _a : 0;
      offset += 50;
    } while (offset < total);
    return trie;
  }
  static processHops(url, trie, bestMatch, options) {
    var _a;
    const isCycle = (id, result) => {
      var _a2;
      if (!id || !result.lastHop)
        return false;
      const set = /* @__PURE__ */ new Set([id]);
      const cycleStack = [result];
      while (cycleStack.length > 0) {
        const cur = cycleStack.pop();
        const redirect = (_a2 = cur == null ? void 0 : cur.definition) == null ? void 0 : _a2.redirect;
        if (!(redirect == null ? void 0 : redirect.id))
          continue;
        if (set.has(redirect.id))
          return true;
        set.add(redirect.id);
        if (cur == null ? void 0 : cur.lastHop) {
          cycleStack.push(cur.lastHop);
        }
      }
      return false;
    };
    const stack = this.processHop(url, trie, bestMatch, options);
    const ret = [];
    while (stack.length > 0) {
      const result = stack.pop();
      if (!(result == null ? void 0 : result.url))
        continue;
      const redirect = (_a = result.definition) == null ? void 0 : _a.redirect;
      const hop = (redirect == null ? void 0 : redirect.stopExecutingAfter) ? [] : this.processHop(result == null ? void 0 : result.url, trie, bestMatch, options).filter(
        (h) => {
          var _a2, _b;
          return ((_a2 = h.definition) == null ? void 0 : _a2.redirect.id) && !isCycle((_b = h.definition) == null ? void 0 : _b.redirect.id, result);
        }
      );
      if (hop.length === 0) {
        ret.unshift(result);
      }
      hop.forEach((h) => {
        stack.push({ ...h, lastHop: result });
      });
    }
    return ret;
  }
  static processHop(url, trie, bestMatch, options) {
    const processedUrl = this.processUrl(url);
    let definition = trie.find(url, false);
    if (!(definition == null ? void 0 : definition.length)) {
      definition = trie.find(processedUrl.path + processedUrl.query, bestMatch);
    }
    if (!(definition == null ? void 0 : definition.length)) {
      definition = trie.find(processedUrl.path, bestMatch);
    }
    if (definition == null ? void 0 : definition.length) {
      return definition.map(
        (def) => this.processDefinitionToResults(processedUrl, def.data, def.variables, options)
      ).filter((r) => Boolean(r));
    }
    return [];
  }
  /**
   * Taking the url, found definition and variables and returning a redirect result object
   * @param processedUrl - Propertly formatted url input
   * @param definition - Redirect definition found to match the processed url
   * @param variables - Wildcard variables found during definition discovery
   * @param options - Different options available to the redirect engine
   */
  static processDefinitionToResults(processedUrl, definition, variables, options) {
    var _a, _b, _c, _d, _e;
    const resultUrl = (options == null ? void 0 : options.reverse) ? definition.redirect.sourceUrl : definition.redirect.targetUrl;
    const processedResult = this.processUrl(resultUrl);
    const redirect = definition == null ? void 0 : definition.redirect;
    if (redirect.sourceMustMatchDomain && processedUrl.domain !== processedResult.domain)
      return void 0;
    const protocol = redirect.targetPreserveIncomingProtocol ? processedUrl.protocol : (_b = (_a = processedResult.protocol) != null ? _a : processedUrl.protocol) != null ? _b : "";
    const domain = redirect.targetPreserveIncomingDomain ? processedUrl.domain : (_d = (_c = processedResult.domain) != null ? _c : processedUrl.domain) != null ? _d : "";
    const queryString = redirect.sourceRetainQuerystring && processedResult.query ? (_e = processedResult.query) != null ? _e : "" : definition.redirect.sourceRetainQuerystring ? processedUrl.query : "";
    const finalUrl = `${protocol}${domain}${processedResult.port}${processedResult.path}${queryString}`;
    return {
      url: variables.reduce((cur, o) => {
        return cur.replace(o.key, o.value);
      }, finalUrl),
      definition,
      label: (options == null ? void 0 : options.label) ? variables.reduce((cur, o) => {
        return cur.replace(o.key, `<em>${o.value}</em>`);
      }, finalUrl) : void 0
    };
  }
  static getTargetVariableExpandedUrl(url, redirectDefinition, isVariable) {
    const processedTarget = this.processUrl(redirectDefinition.targetUrl);
    const processedSource = this.processUrl(redirectDefinition.sourceUrl);
    let finalUrlPath = processedTarget.path;
    const processedUrl = this.processUrl(url);
    const variables = this.getSourceVariables(processedUrl.path, processedSource.path, isVariable);
    for (const variable in variables) {
      finalUrlPath = finalUrlPath.replace(variable, variables[variable]);
    }
    const protocol = redirectDefinition.targetPreserveIncomingProtocol ? processedUrl.protocol : processedTarget.protocol;
    const domain = redirectDefinition.targetPreserveIncomingDomain ? processedUrl.domain : processedTarget.domain;
    const port = processedTarget.port;
    const query = redirectDefinition.sourceRetainQuerystring && redirectDefinition.targetMergeQuerystring ? this.mergeQueryStrings(processedUrl.query, processedTarget.query) : !redirectDefinition.targetMergeQuerystring && redirectDefinition.sourceRetainQuerystring ? processedUrl.query : processedTarget.query;
    const fragment = redirectDefinition.sourceRetainQuerystring && redirectDefinition.targetMergeQuerystring ? this.mergeQueryStrings(processedUrl.fragment, processedTarget.fragment) : !redirectDefinition.targetMergeQuerystring && redirectDefinition.sourceRetainQuerystring ? processedUrl.fragment : processedTarget.fragment;
    return `${protocol}${domain}${port}${finalUrlPath}${query}${fragment}`;
  }
  static mergeQueryStrings(qs1, qs2) {
    let fragment = false;
    if (qs1.startsWith("#")) {
      fragment = true;
      qs1 = qs1.substring(1);
    }
    if (qs2.startsWith("#")) {
      fragment = true;
      qs2 = qs2.substring(1);
    }
    const params1 = new URLSearchParams(qs1);
    const params2 = new URLSearchParams(qs2);
    const merged = new URLSearchParams([...params1, ...params2]).toString();
    if (merged.length > 0)
      return (fragment ? "#" : "?") + merged;
    return "";
  }
  static getSourceVariables(path, source, isVariable = (pathSegment) => pathSegment.startsWith(":")) {
    const variables = {};
    const pathSegments = path.split("/");
    const sourceSegments = source.split("/");
    if (pathSegments.length !== sourceSegments.length) {
      throw new Error("Path and source have different numbers of path segments, must be the same");
    }
    sourceSegments.forEach((sourceSegment, i) => {
      if (isVariable(sourceSegment)) {
        variables[sourceSegment] = pathSegments[i];
      }
    });
    return variables;
  }
  static processUrl(url) {
    var _a, _b, _c, _d, _e, _f;
    const matches = url.match(/^(https?:\/\/)?(([^:/?#]*)(?:(:[0-9]+))?)?([/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/);
    return {
      url,
      protocol: (_a = matches == null ? void 0 : matches[1]) != null ? _a : "",
      domain: (_b = matches == null ? void 0 : matches[3]) != null ? _b : "",
      port: (_c = matches == null ? void 0 : matches[4]) != null ? _c : "",
      path: (_d = matches == null ? void 0 : matches[5]) != null ? _d : "",
      query: (_e = matches == null ? void 0 : matches[6]) != null ? _e : "",
      fragment: (_f = matches == null ? void 0 : matches[7]) != null ? _f : ""
    };
  }
};
var RedirectClient = _RedirectClient;
RedirectClient.processUrlBestMatch = async (url, trie, options) => {
  var _a;
  return (_a = _RedirectClient.processHops(url, trie, true, options)) == null ? void 0 : _a[0];
};
var UncachedRedirectClient = class extends RedirectClient {
  constructor(options) {
    super({ ...options, bypassCache: true });
  }
};

// src/util/RedirectFileConverter.ts
var getDefaultClient = async () => {
  const dotenv = await Promise.resolve().then(() => __toESM(require_main()));
  dotenv.config();
  return new RedirectClient({
    apiKey: process.env.UNIFORM_API_KEY,
    apiHost: process.env.UNIFORM_BASE_URL,
    projectId: process.env.UNIFORM_PROJECT_ID
  });
};
function ExtractWildcards(url) {
  let last = "";
  let wildcardStart = -1;
  const terminators = ["/", "?", "&", "#"];
  const ret = [];
  for (let i = 0; i < url.length; i++) {
    const cur = url.charAt(i);
    if (terminators.includes(last) && cur === ":") {
      wildcardStart = i;
    }
    if (terminators.includes(cur) && wildcardStart !== -1) {
      ret.push({ index: wildcardStart, pathSegment: url.substring(wildcardStart, i) });
      wildcardStart = -1;
    }
    last = cur;
  }
  if (wildcardStart > -1) {
    ret.push({ index: wildcardStart, pathSegment: url.substring(wildcardStart) });
  }
  if (last === "*") {
    ret.push({ index: url.length, pathSegment: "*" });
  }
  return ret;
}
async function RedirectFileConverter({
  client,
  redirectEntryObject,
  wildcardConverter = (s) => s,
  writeFile
}) {
  if (!client) {
    client = await getDefaultClient();
  }
  let redirects = (await client.getRedirects({ limit: 50, offset: 0 })).redirects;
  let count = 0;
  const ret = [];
  while (redirects.length) {
    const redirect = redirects.pop();
    if (redirect == null ? void 0 : redirect.redirect) {
      const st = wildcardConverter({
        ...redirect.redirect,
        sourceWildcards: ExtractWildcards(redirect.redirect.sourceUrl),
        targetWildcards: ExtractWildcards(redirect.redirect.targetUrl)
      });
      ret.push(
        redirectEntryObject({
          metadata: redirect.metadata,
          redirect: {
            ...redirect.redirect,
            sourceUrl: st.sourceUrl,
            targetUrl: st.targetUrl
          }
        })
      );
    }
    if (!redirects.length) {
      count++;
      redirects = (await client.getRedirects({ limit: 50, offset: count * 50 })).redirects;
    }
  }
  writeFile(ret);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExtractWildcards,
  PathTrie,
  PathTrieData,
  RedirectClient,
  RedirectFileConverter,
  UncachedRedirectClient,
  WithMemoryCache
});
