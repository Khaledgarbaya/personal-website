import "./chunk-FFYIGW52.mjs";

// src/cache/redirectClientCache.ts
var RedirectClientCache = class {
  constructor(options) {
    this.options = options;
  }
};

// src/cache/withMemoryCache.ts
var _WithMemoryCache = class extends RedirectClientCache {
  constructor(options) {
    super(options);
  }
  /* Get data from the cache and debounce pausing refresh */
  get(key) {
    var _a, _b;
    return (_b = (_a = _WithMemoryCache.trieCache[key]) == null ? void 0 : _a.data) != null ? _b : void 0;
  }
  /* Set new data to the cache and reset the refresh method */
  set(key, data, refresh) {
    var _a;
    if (!data)
      return;
    const setCache = () => {
      _WithMemoryCache.trieCache[key] = {
        ..._WithMemoryCache.trieCache[key],
        data,
        refresh
      };
    };
    if (!((_a = _WithMemoryCache.trieCache[key]) == null ? void 0 : _a.data)) {
      setCache();
    } else {
      data.then(() => {
        setCache();
      });
    }
  }
  refresh() {
    var _a, _b;
    for (const key in _WithMemoryCache.trieCache) {
      const p = (_b = (_a = _WithMemoryCache.trieCache[key]) == null ? void 0 : _a.refresh) == null ? void 0 : _b.call(_a);
      if (p) {
        _WithMemoryCache.trieCache[key] = { ..._WithMemoryCache.trieCache[key], data: p };
      }
    }
    return Promise.all([]);
  }
};
var WithMemoryCache = _WithMemoryCache;
/* Memory static class level variable to store data across multiple instances of the redirect client */
WithMemoryCache.trieCache = {};

// src/data/pathTrie.ts
import rfdc from "rfdc";
var dataProp = "~~data~~";
var PathTrie = class {
  constructor(initialData) {
    this.map = new PathTrieData();
    this.splitUrl = (url) => {
      if (url.startsWith("https://"))
        return ["https://", ...url.substring("https://".length).split("/")].filter((segment) => segment.length);
      if (url.startsWith("http://"))
        return ["http://", ...url.substring("http://".length).split("/")].filter((segment) => segment.length);
      return url.split("/").filter((segment) => segment.length);
    };
    this.clone = rfdc();
    if (initialData) {
      if (Object.hasOwn(initialData, "map")) {
        this.map = initialData.map;
      } else {
        this.map = initialData;
      }
    }
  }
  convertManyInsert(data, key, value) {
    data == null ? void 0 : data.forEach((d) => {
      if (value) {
        this.insert(key(d), value(d));
      } else {
        this.insert(key(d), d);
      }
    });
  }
  insertMany(data, key) {
    data.forEach((d) => {
      this.insert(key(d), d);
    });
  }
  insert(path, data) {
    let cur = this.map;
    const segments = this.splitUrl(path);
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === 0 && segment === "")
        continue;
      if (!Object.hasOwn(cur, segment)) {
        cur[segment] = new PathTrieData();
      }
      cur = cur[segment];
      if (i == segments.length - 1) {
        if (!cur[dataProp]) {
          cur[dataProp] = [];
        }
        cur[dataProp].push(data);
      }
    }
  }
  find(path, bestMatch = true) {
    let cur = this.clone(this.map);
    const segments = this.splitUrl(path);
    const wildcards = [];
    const ret = [];
    const splats = [];
    const processed = /* @__PURE__ */ new Set();
    const getVariables = () => {
      return wildcards.map((wildcard) => {
        if (wildcard.active)
          return { key: wildcard.name, value: segments[wildcard.start] };
        return void 0;
      }).filter((wildcard) => Boolean(wildcard));
    };
    const getPropsStartingWithColon = (obj) => {
      const result = [];
      for (const prop in obj) {
        if (prop.startsWith(":")) {
          result.push(prop);
        }
      }
      return result;
    };
    const scanWildcards = () => {
      let wildcard = void 0;
      while ((!wildcard || wildcard.active) && wildcards.length) {
        wildcard = wildcards.pop();
      }
      if (!wildcard || wildcard.active)
        return void 0;
      wildcard.active = true;
      cur = wildcard == null ? void 0 : wildcard.startTrie;
      wildcards.push(wildcard);
      return wildcard == null ? void 0 : wildcard.start;
    };
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (Object.hasOwn(cur, "*")) {
        cur["*"][dataProp].forEach((splat) => {
          splats.push({
            data: splat,
            variables: [...getVariables(), { key: ":splat", value: segments.slice(i).join("/") }]
          });
        });
      }
      getPropsStartingWithColon(cur).forEach((wildcard) => {
        if (!processed.has(wildcard)) {
          wildcards.push({
            startTrie: cur[wildcard],
            start: i,
            active: false,
            name: wildcard
          });
          processed.add(wildcard);
        }
      });
      if (Object.hasOwn(cur, segment)) {
        cur = cur[segment];
        if (i === segments.length - 1) {
          if (cur[dataProp]) {
            cur[dataProp].forEach((d) => ret.push({ data: d, variables: getVariables() }));
          }
        }
      } else if (i === segments.length - 1) {
        const more = scanWildcards();
        if (typeof more === "undefined")
          return [...ret, ...splats];
        i = more;
        if (i === segments.length - 1 && wildcards.length && wildcards[wildcards.length - 1].active && wildcards[wildcards.length - 1].startTrie[dataProp]) {
          wildcards[wildcards.length - 1].startTrie[dataProp].forEach(
            (d) => ret.push({ data: d, variables: getVariables() })
          );
        }
      } else {
        const more = scanWildcards();
        if (typeof more === "undefined")
          return [...ret, ...splats];
        i = more;
      }
      if (ret.length > 0 && bestMatch)
        return [...ret, ...splats];
    }
    return [...ret, ...splats];
  }
};
var PathTrieData = class {
};

// src/redirectClient.ts
import { ApiClient } from "@uniformdev/context/api";
var _RedirectClient = class extends ApiClient {
  constructor(options) {
    super(options);
    this.getRedirect = async (options) => {
      var _a;
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/redirect", { ...options, projectId });
      const results = await this.apiClient(fetchUri);
      return (_a = results.redirects) == null ? void 0 : _a[0];
    };
    this.getRedirects = async (options) => {
      const { projectId } = this.options;
      const fetchUri = this.createUrl("/api/v1/redirect", { ...options, projectId });
      const results = await this.apiClient(fetchUri);
      return results;
    };
    this.getRedirectTrie = async (options) => {
      var _a, _b;
      const { projectId } = this.options;
      const key = `${projectId}${(options == null ? void 0 : options.reverse) ? "r" : "f"}`;
      const cachePromise = (options == null ? void 0 : options.bypassDataCache) ? void 0 : (_a = this.options.dataCache) == null ? void 0 : _a.get(key);
      if (cachePromise) {
        const result = await cachePromise;
        if (result)
          return result;
      }
      const ret = this.assembleTrie(projectId, options);
      (_b = this.options.dataCache) == null ? void 0 : _b.set(key, ret, () => this.assembleTrie(projectId, options));
      return ret;
    };
    this.resetRedirectTrieDataCache = async () => {
      var _a;
      await ((_a = this.options.dataCache) == null ? void 0 : _a.refresh());
    };
    this.upsertRedirect = async (redirect) => {
      const {
        id,
        sourceUrl,
        targetStatusCode,
        targetUrl,
        labelAsSystem,
        projectMapId,
        sourceMustMatchDomain,
        sourceProjectMapNodeId,
        sourceRetainQuerystring,
        stopExecutingAfter,
        targetMergeQuerystring,
        targetPreserveIncomingDomain,
        targetPreserveIncomingProtocol,
        targetProjectMapNodeId
      } = redirect;
      const fetchUri = this.createUrl("/api/v1/redirect");
      const result = await this.apiClient(fetchUri, {
        method: "PUT",
        body: JSON.stringify({
          redirect: {
            id,
            sourceUrl,
            targetStatusCode,
            targetUrl,
            labelAsSystem,
            projectMapId,
            sourceMustMatchDomain,
            sourceProjectMapNodeId,
            sourceRetainQuerystring,
            stopExecutingAfter,
            targetMergeQuerystring,
            targetPreserveIncomingDomain,
            targetPreserveIncomingProtocol,
            targetProjectMapNodeId
          },
          projectId: this.options.projectId
        })
      });
      this.resetRedirectTrieDataCache();
      return result.id;
    };
    this.deleteRedirect = async (id) => {
      const fetchUri = this.createUrl("/api/v1/redirect");
      const result = await this.apiClient(fetchUri, {
        method: "DELETE",
        body: JSON.stringify({ id, projectId: this.options.projectId })
      });
      this.resetRedirectTrieDataCache();
      return result.id;
    };
    this.processUrlBestMatch = async (url, options) => {
      var _a;
      const trie = await this.getRedirectTrie({ reverse: Boolean(options == null ? void 0 : options.reverse) });
      return (_a = _RedirectClient.processHops(url, trie, true, options)) == null ? void 0 : _a[0];
    };
    this.processUrlAllMatches = async (url, options) => {
      const trie = await this.getRedirectTrie({ reverse: Boolean(options == null ? void 0 : options.reverse) });
      return _RedirectClient.processHops(url, trie, false, options);
    };
    if (options.dataCache && options.dataCache.options.prePopulate) {
      if (!options.dataCache.get(`${options.projectId}f`)) {
        options.dataCache.set(
          `${options.projectId}f`,
          this.getRedirectTrie(),
          () => this.getRedirectTrie({ bypassDataCache: true })
        );
      }
    }
  }
  async assembleTrie(projectId, options) {
    var _a;
    const trie = new PathTrie();
    let offset = 0;
    let total = 0;
    do {
      const fetchUri = this.createUrl("/api/v1/redirect", {
        projectId,
        limit: 50,
        offset
      });
      const redirects = await this.apiClient(fetchUri);
      trie.insertMany(
        redirects.redirects,
        (r) => (options == null ? void 0 : options.reverse) ? r.redirect.targetUrl : r.redirect.sourceUrl
      );
      total = (_a = redirects.total) != null ? _a : 0;
      offset += 50;
    } while (offset < total);
    return trie;
  }
  static processHops(url, trie, bestMatch, options) {
    var _a;
    const isCycle = (id, result) => {
      var _a2;
      if (!id || !result.lastHop)
        return false;
      const set = /* @__PURE__ */ new Set([id]);
      const cycleStack = [result];
      while (cycleStack.length > 0) {
        const cur = cycleStack.pop();
        const redirect = (_a2 = cur == null ? void 0 : cur.definition) == null ? void 0 : _a2.redirect;
        if (!(redirect == null ? void 0 : redirect.id))
          continue;
        if (set.has(redirect.id))
          return true;
        set.add(redirect.id);
        if (cur == null ? void 0 : cur.lastHop) {
          cycleStack.push(cur.lastHop);
        }
      }
      return false;
    };
    const stack = this.processHop(url, trie, bestMatch, options);
    const ret = [];
    while (stack.length > 0) {
      const result = stack.pop();
      if (!(result == null ? void 0 : result.url))
        continue;
      const redirect = (_a = result.definition) == null ? void 0 : _a.redirect;
      const hop = (redirect == null ? void 0 : redirect.stopExecutingAfter) ? [] : this.processHop(result == null ? void 0 : result.url, trie, bestMatch, options).filter(
        (h) => {
          var _a2, _b;
          return ((_a2 = h.definition) == null ? void 0 : _a2.redirect.id) && !isCycle((_b = h.definition) == null ? void 0 : _b.redirect.id, result);
        }
      );
      if (hop.length === 0) {
        ret.unshift(result);
      }
      hop.forEach((h) => {
        stack.push({ ...h, lastHop: result });
      });
    }
    return ret;
  }
  static processHop(url, trie, bestMatch, options) {
    const processedUrl = this.processUrl(url);
    let definition = trie.find(url, false);
    if (!(definition == null ? void 0 : definition.length)) {
      definition = trie.find(processedUrl.path + processedUrl.query, bestMatch);
    }
    if (!(definition == null ? void 0 : definition.length)) {
      definition = trie.find(processedUrl.path, bestMatch);
    }
    if (definition == null ? void 0 : definition.length) {
      return definition.map(
        (def) => this.processDefinitionToResults(processedUrl, def.data, def.variables, options)
      ).filter((r) => Boolean(r));
    }
    return [];
  }
  /**
   * Taking the url, found definition and variables and returning a redirect result object
   * @param processedUrl - Propertly formatted url input
   * @param definition - Redirect definition found to match the processed url
   * @param variables - Wildcard variables found during definition discovery
   * @param options - Different options available to the redirect engine
   */
  static processDefinitionToResults(processedUrl, definition, variables, options) {
    var _a, _b, _c, _d, _e;
    const resultUrl = (options == null ? void 0 : options.reverse) ? definition.redirect.sourceUrl : definition.redirect.targetUrl;
    const processedResult = this.processUrl(resultUrl);
    const redirect = definition == null ? void 0 : definition.redirect;
    if (redirect.sourceMustMatchDomain && processedUrl.domain !== processedResult.domain)
      return void 0;
    const protocol = redirect.targetPreserveIncomingProtocol ? processedUrl.protocol : (_b = (_a = processedResult.protocol) != null ? _a : processedUrl.protocol) != null ? _b : "";
    const domain = redirect.targetPreserveIncomingDomain ? processedUrl.domain : (_d = (_c = processedResult.domain) != null ? _c : processedUrl.domain) != null ? _d : "";
    const queryString = redirect.sourceRetainQuerystring && processedResult.query ? (_e = processedResult.query) != null ? _e : "" : definition.redirect.sourceRetainQuerystring ? processedUrl.query : "";
    const finalUrl = `${protocol}${domain}${processedResult.port}${processedResult.path}${queryString}`;
    return {
      url: variables.reduce((cur, o) => {
        return cur.replace(o.key, o.value);
      }, finalUrl),
      definition,
      label: (options == null ? void 0 : options.label) ? variables.reduce((cur, o) => {
        return cur.replace(o.key, `<em>${o.value}</em>`);
      }, finalUrl) : void 0
    };
  }
  static getTargetVariableExpandedUrl(url, redirectDefinition, isVariable) {
    const processedTarget = this.processUrl(redirectDefinition.targetUrl);
    const processedSource = this.processUrl(redirectDefinition.sourceUrl);
    let finalUrlPath = processedTarget.path;
    const processedUrl = this.processUrl(url);
    const variables = this.getSourceVariables(processedUrl.path, processedSource.path, isVariable);
    for (const variable in variables) {
      finalUrlPath = finalUrlPath.replace(variable, variables[variable]);
    }
    const protocol = redirectDefinition.targetPreserveIncomingProtocol ? processedUrl.protocol : processedTarget.protocol;
    const domain = redirectDefinition.targetPreserveIncomingDomain ? processedUrl.domain : processedTarget.domain;
    const port = processedTarget.port;
    const query = redirectDefinition.sourceRetainQuerystring && redirectDefinition.targetMergeQuerystring ? this.mergeQueryStrings(processedUrl.query, processedTarget.query) : !redirectDefinition.targetMergeQuerystring && redirectDefinition.sourceRetainQuerystring ? processedUrl.query : processedTarget.query;
    const fragment = redirectDefinition.sourceRetainQuerystring && redirectDefinition.targetMergeQuerystring ? this.mergeQueryStrings(processedUrl.fragment, processedTarget.fragment) : !redirectDefinition.targetMergeQuerystring && redirectDefinition.sourceRetainQuerystring ? processedUrl.fragment : processedTarget.fragment;
    return `${protocol}${domain}${port}${finalUrlPath}${query}${fragment}`;
  }
  static mergeQueryStrings(qs1, qs2) {
    let fragment = false;
    if (qs1.startsWith("#")) {
      fragment = true;
      qs1 = qs1.substring(1);
    }
    if (qs2.startsWith("#")) {
      fragment = true;
      qs2 = qs2.substring(1);
    }
    const params1 = new URLSearchParams(qs1);
    const params2 = new URLSearchParams(qs2);
    const merged = new URLSearchParams([...params1, ...params2]).toString();
    if (merged.length > 0)
      return (fragment ? "#" : "?") + merged;
    return "";
  }
  static getSourceVariables(path, source, isVariable = (pathSegment) => pathSegment.startsWith(":")) {
    const variables = {};
    const pathSegments = path.split("/");
    const sourceSegments = source.split("/");
    if (pathSegments.length !== sourceSegments.length) {
      throw new Error("Path and source have different numbers of path segments, must be the same");
    }
    sourceSegments.forEach((sourceSegment, i) => {
      if (isVariable(sourceSegment)) {
        variables[sourceSegment] = pathSegments[i];
      }
    });
    return variables;
  }
  static processUrl(url) {
    var _a, _b, _c, _d, _e, _f;
    const matches = url.match(/^(https?:\/\/)?(([^:/?#]*)(?:(:[0-9]+))?)?([/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/);
    return {
      url,
      protocol: (_a = matches == null ? void 0 : matches[1]) != null ? _a : "",
      domain: (_b = matches == null ? void 0 : matches[3]) != null ? _b : "",
      port: (_c = matches == null ? void 0 : matches[4]) != null ? _c : "",
      path: (_d = matches == null ? void 0 : matches[5]) != null ? _d : "",
      query: (_e = matches == null ? void 0 : matches[6]) != null ? _e : "",
      fragment: (_f = matches == null ? void 0 : matches[7]) != null ? _f : ""
    };
  }
};
var RedirectClient = _RedirectClient;
RedirectClient.processUrlBestMatch = async (url, trie, options) => {
  var _a;
  return (_a = _RedirectClient.processHops(url, trie, true, options)) == null ? void 0 : _a[0];
};
var UncachedRedirectClient = class extends RedirectClient {
  constructor(options) {
    super({ ...options, bypassCache: true });
  }
};

// src/util/RedirectFileConverter.ts
var getDefaultClient = async () => {
  const dotenv = await import("./main-NHOL4NFR.mjs");
  dotenv.config();
  return new RedirectClient({
    apiKey: process.env.UNIFORM_API_KEY,
    apiHost: process.env.UNIFORM_BASE_URL,
    projectId: process.env.UNIFORM_PROJECT_ID
  });
};
function ExtractWildcards(url) {
  let last = "";
  let wildcardStart = -1;
  const terminators = ["/", "?", "&", "#"];
  const ret = [];
  for (let i = 0; i < url.length; i++) {
    const cur = url.charAt(i);
    if (terminators.includes(last) && cur === ":") {
      wildcardStart = i;
    }
    if (terminators.includes(cur) && wildcardStart !== -1) {
      ret.push({ index: wildcardStart, pathSegment: url.substring(wildcardStart, i) });
      wildcardStart = -1;
    }
    last = cur;
  }
  if (wildcardStart > -1) {
    ret.push({ index: wildcardStart, pathSegment: url.substring(wildcardStart) });
  }
  if (last === "*") {
    ret.push({ index: url.length, pathSegment: "*" });
  }
  return ret;
}
async function RedirectFileConverter({
  client,
  redirectEntryObject,
  wildcardConverter = (s) => s,
  writeFile
}) {
  if (!client) {
    client = await getDefaultClient();
  }
  let redirects = (await client.getRedirects({ limit: 50, offset: 0 })).redirects;
  let count = 0;
  const ret = [];
  while (redirects.length) {
    const redirect = redirects.pop();
    if (redirect == null ? void 0 : redirect.redirect) {
      const st = wildcardConverter({
        ...redirect.redirect,
        sourceWildcards: ExtractWildcards(redirect.redirect.sourceUrl),
        targetWildcards: ExtractWildcards(redirect.redirect.targetUrl)
      });
      ret.push(
        redirectEntryObject({
          metadata: redirect.metadata,
          redirect: {
            ...redirect.redirect,
            sourceUrl: st.sourceUrl,
            targetUrl: st.targetUrl
          }
        })
      );
    }
    if (!redirects.length) {
      count++;
      redirects = (await client.getRedirects({ limit: 50, offset: count * 50 })).redirects;
    }
  }
  writeFile(ret);
}
export {
  ExtractWildcards,
  PathTrie,
  PathTrieData,
  RedirectClient,
  RedirectFileConverter,
  UncachedRedirectClient,
  WithMemoryCache
};
