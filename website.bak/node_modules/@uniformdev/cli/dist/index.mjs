#!/usr/bin/env node

// src/index.ts
import * as dotenv from "dotenv";
import yargs19 from "yargs";
import { hideBin } from "yargs/helpers";

// src/commands/canvas/index.ts
import yargs4 from "yargs";

// src/commands/canvas/commands/component.ts
import yargs from "yargs";

// src/commands/canvas/commands/component/get.ts
import { UncachedCanvasClient } from "@uniformdev/canvas";

// src/sync/arraySyncEngineDataSource.ts
async function createArraySyncEngineDataSource({
  objects,
  selectIdentifier: selectIdentifier12,
  selectDisplayName: selectDisplayName12 = selectIdentifier12,
  onSyncComplete
}) {
  const objectIndex = objects.reduce(
    (result, current) => {
      const rawIdentifiers = selectIdentifier12(current);
      const identifiers = Array.isArray(rawIdentifiers) ? rawIdentifiers : [rawIdentifiers];
      const existingResult = identifiers.find((id) => result[id]);
      if (existingResult) {
        throw new Error(`Identifier(s) ${identifiers} was not unique.`);
      }
      const displayName = selectDisplayName12(current);
      result[identifiers[0]] = {
        id: identifiers,
        object: current,
        providerId: identifiers[0],
        displayName: Array.isArray(displayName) ? displayName[0] : displayName
      };
      identifiers.slice(1).forEach((id) => result[id] = identifiers[0]);
      return result;
    },
    {}
  );
  async function* getObjects() {
    for (const item of Object.values(objectIndex)) {
      if (typeof item === "object")
        yield item;
    }
  }
  function extractCurrent() {
    return Object.entries(objectIndex).filter((entry) => typeof entry[1] === "object").sort((a, b) => a[0].localeCompare(b[0])).map((entry) => entry[1].object);
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      delete objectIndex[providerId];
    },
    writeObject: async (objectToWrite) => {
      const id = selectIdentifier12(objectToWrite.object);
      if (Array.isArray(id)) {
        objectIndex[id[0]] = objectToWrite;
      } else {
        objectIndex[id] = objectToWrite;
      }
    },
    extractCurrent,
    onSyncComplete: onSyncComplete ? (isTarget) => onSyncComplete(isTarget, extractCurrent()) : void 0
  };
}

// src/sync/fileSyncEngineDataSource.ts
import { red } from "colorette";
import { existsSync, mkdirSync } from "fs";
import { readdir, unlink } from "fs/promises";
import { extname as extname2, join } from "path";

// src/util.ts
var omit = (object, keys) => {
  const result = keys.reduce((current, key) => {
    const { [key]: _, ...rest } = current;
    return rest;
  }, object);
  return result;
};
var cleanFileName = (proposedFileName) => {
  return proposedFileName.replace(/[/<>$+%>!`&*'|{}?"=:\\@]/g, "-");
};

// src/sync/util.ts
import { readFileSync, writeFileSync } from "fs";
import httpsProxyAgent from "https-proxy-agent";
import unfetch from "isomorphic-unfetch";
import { dump, load } from "js-yaml";
import { extname } from "path";
function withApiOptions(yargs20) {
  return yargs20.option("apiKey", {
    describe: "Uniform API key. Defaults to UNIFORM_CLI_API_KEY or UNIFORM_API_KEY env. Supports dotenv.",
    default: process.env.UNIFORM_CLI_API_KEY ?? // deprecated
    process.env.CANVAS_CLI_API_KEY ?? // deprecated
    process.env.UPM_CLI_API_KEY ?? process.env.UNIFORM_API_KEY,
    demandOption: true,
    type: "string"
  }).option("apiHost", {
    describe: "Uniform host. Defaults to UNIFORM_CLI_BASE_URL env var or https://uniform.app. Supports dotenv.",
    default: process.env.UNIFORM_CLI_BASE_URL || "https://uniform.app",
    demandOption: true,
    type: "string"
  }).option("edgeApiHost", {
    describe: "Uniform edge host. Defaults to UNIFORM_CLI_BASE_EDGE_URL env var or https://uniform.global. Supports dotenv.",
    default: process.env.UNIFORM_CLI_BASE_EDGE_URL || "https://uniform.global",
    demandOption: true,
    type: "string"
  }).option("proxy", {
    describe: "HTTPS proxy to use for Uniform API calls. Defaults to HTTPS_PROXY, https_proxy, ALL_PROXY, or all_proxy env vars (in that order). Supports dotenv.",
    default: process.env.HTTPS_PROXY || process.env.https_proxy || process.env.ALL_PROXY || process.env.all_proxy,
    type: "string"
  });
}
function nodeFetchProxy(proxy) {
  if (proxy) {
    console.log(`\u{1F991} Using proxy ${proxy}`);
  }
  const wrappedFetch = (input, init) => {
    if (proxy) {
      const wrappedInit = {
        ...init,
        agent: new httpsProxyAgent.HttpsProxyAgent(proxy)
      };
      return unfetch(input, wrappedInit);
    }
    return unfetch(input, init);
  };
  return wrappedFetch;
}
function withProjectOptions(yargs20) {
  return yargs20.option("project", {
    describe: "Uniform project ID. Defaults to UNIFORM_CLI_PROJECT_ID or UNIFORM_PROJECT_ID env. Supports dotenv.",
    default: process.env.UNIFORM_CLI_PROJECT_ID ?? // deprecated
    process.env.CANVAS_CLI_PROJECT_ID ?? // deprecated
    process.env.UPM_CLI_PROJECT_ID ?? process.env.UNIFORM_PROJECT_ID,
    demandOption: true,
    type: "string",
    alias: ["p"]
  });
}
function withFormatOptions(yargs20) {
  return yargs20.option("format", {
    alias: ["f"],
    describe: "Output format",
    default: "yaml",
    choices: ["yaml", "json"],
    type: "string"
  }).option("filename", {
    alias: ["o"],
    describe: "Output filename. If not specified, write to stdout.",
    type: "string"
  });
}
function withDiffOptions(yargs20) {
  return yargs20.option("diff", {
    describe: "Whether to show diffs in stdout. off = no diffs; update = on for updates; on = updates, creates, deletes. Can be set by UNIFORM_CLI_DIFF_MODE environment variable.",
    default: process.env.UNIFORM_CLI_DIFF_MODE ?? "off",
    type: "string",
    choices: ["off", "update", "on"],
    alias: ["d"]
  });
}
function isPathAPackageFile(path4) {
  const extension = extname(path4);
  return extension === ".yaml" || extension === ".yml" || extension === ".json";
}
function emitWithFormat(object, format, filename) {
  let content;
  if (filename && !format) {
    const extension = extname(filename);
    if (extension === ".yaml" || extension === ".yml") {
      format = "yaml";
    } else if (extension === ".json") {
      format = "json";
    }
  } else if (!format) {
    throw new Error("Format must be specified when no filename is passed");
  }
  switch (format) {
    case "json":
      content = JSON.stringify(object, null, 2);
      break;
    case "yaml":
      content = dump(object);
      if ("$schema" in object) {
        content = `# yaml-language-server: $schema=<${object["$schema"]}>
${content}`;
      }
      break;
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
  if (filename) {
    writeFileSync(filename, content, "utf8");
  } else {
    console.log(content);
  }
}
function readFileToObject(filename) {
  const file = readFileSync(filename, "utf8");
  return load(file, { filename, json: true });
}
async function* paginateAsync(fetchPage, options) {
  const perPage = options.pageSize || 100;
  let offset = 0;
  let pageData = [];
  do {
    pageData = await fetchPage(offset, perPage);
    for (const item of pageData) {
      yield item;
    }
    offset += perPage;
  } while (pageData.length === perPage);
}

// src/sync/fileSyncEngineDataSource.ts
async function createFileSyncEngineDataSource({
  directory,
  format = "yaml",
  selectIdentifier: selectIdentifier12,
  selectDisplayName: selectDisplayName12 = selectIdentifier12,
  selectFilename: selectFilename3,
  selectSchemaUrl: selectSchemaUrl2
}) {
  const dirExists = existsSync(directory);
  if (!dirExists) {
    mkdirSync(directory, { recursive: true });
  }
  const rawFilenames = await readdir(directory, "utf-8");
  const filenames = new Set(
    rawFilenames.filter((filename) => {
      const ext = extname2(filename);
      return ext === `.json` || ext === `.yaml` || ext === `.yml`;
    })
  );
  const getFullFilename = (id) => join(directory, `${Array.isArray(id) ? id[0] : id}.${format}`);
  async function* getObjects() {
    for (const filename of filenames) {
      const fullFilename = join(directory, filename);
      try {
        const contents = await readFileToObject(fullFilename);
        const displayName = selectDisplayName12(contents);
        const object = {
          id: selectIdentifier12(contents),
          displayName: Array.isArray(displayName) ? displayName[0] : displayName,
          providerId: fullFilename,
          object: omit(contents, ["$schema"])
        };
        yield object;
      } catch (e) {
        console.error(red(`Failed to read ${fullFilename}, data is likely invalid.
${e == null ? void 0 : e.message}`));
        throw e;
      }
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await unlink(providerId);
    },
    writeObject: async (object) => {
      const filename = selectFilename3 ? join(directory, `${selectFilename3(object.object)}.${format}`) : getFullFilename(object.id);
      let contents = object.object;
      if (selectSchemaUrl2) {
        contents = {
          $schema: selectSchemaUrl2(object.object),
          ...object.object
        };
      }
      emitWithFormat(contents, format, filename);
    }
  };
}

// src/sync/package.ts
import fs from "fs";
function readUniformPackage(filename, assertExists) {
  if (!assertExists && !fs.existsSync(filename)) {
    return {};
  }
  const packageContents = readFileToObject(filename);
  if (typeof packageContents !== "object") {
    throw new Error(`Package ${filename} does not appear valid.`);
  }
  return packageContents;
}
function writeUniformPackage(filename, packageContents) {
  emitWithFormat(packageContents, void 0, filename);
}

// src/sync/syncEngine.ts
import { diffJson, diffLines } from "diff";
import isEqualWith from "lodash.isequalwith";
async function syncEngine({
  source,
  target,
  compareContents = (source2, target2) => {
    return isEqualWith(
      source2.object,
      target2.object,
      (_a, _b, key) => key === "created" || key === "modified" || key === "updated" ? true : void 0
    );
  },
  mode,
  allowEmptySource = false,
  whatIf = false,
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  log = () => {
  }
}) {
  var _a, _b;
  const targetItems = /* @__PURE__ */ new Map();
  const deleteTracker = /* @__PURE__ */ new Set();
  const processDelete = async (object) => {
    if (deleteTracker.has(object))
      return;
    deleteTracker.add(object);
    if (!whatIf) {
      try {
        await target.deleteObject(object.providerId, object);
      } catch (e) {
        throw new SyncEngineError(e, object);
      }
    }
    log({
      action: "delete",
      id: object.id[0],
      providerId: object.providerId,
      displayName: object.displayName ?? object.providerId,
      whatIf,
      diff: diffLines(JSON.stringify(object.object, null, 2), "")
    });
  };
  for await (const obj of target.objects) {
    if (Array.isArray(obj.id)) {
      obj.id.forEach((o) => targetItems.set(o, obj));
    } else {
      targetItems.set(obj.id, obj);
    }
  }
  const actions = [];
  let sourceHasItems = false;
  for await (const sourceObject of source.objects) {
    sourceHasItems = true;
    const ids = Array.isArray(sourceObject.id) ? sourceObject.id : [sourceObject.id];
    const targetObject = targetItems.get(ids[0]);
    const invalidTargetObjects = ids.map((i) => targetItems.get(i)).filter((o) => (o == null ? void 0 : o.object) !== (targetObject == null ? void 0 : targetObject.object));
    if (targetObject && invalidTargetObjects.length == 0) {
      if (!compareContents(sourceObject, targetObject)) {
        if (mode === "createOrUpdate" || mode === "mirror") {
          const process2 = async (sourceObject2, targetObject2) => {
            if (!whatIf) {
              try {
                await target.writeObject(sourceObject2, targetObject2);
              } catch (e) {
                throw new SyncEngineError(e, sourceObject2);
              }
            }
            log({
              action: "update",
              id: ids[0],
              providerId: sourceObject2.providerId,
              displayName: sourceObject2.displayName ?? sourceObject2.providerId,
              whatIf,
              diff: diffJson(targetObject2.object, sourceObject2.object)
            });
          };
          actions.push(process2(sourceObject, targetObject));
        }
      }
      ids.forEach((i) => targetItems.delete(i));
    } else {
      const process2 = async (sourceObject2, id) => {
        if (!whatIf) {
          try {
            await target.writeObject(sourceObject2);
          } catch (e) {
            throw new SyncEngineError(e, sourceObject2);
          }
        }
        log({
          action: "create",
          id,
          providerId: id,
          displayName: sourceObject2.displayName ?? sourceObject2.providerId,
          whatIf,
          diff: diffLines("", JSON.stringify(sourceObject2.object, null, 2))
        });
      };
      if (invalidTargetObjects.length > 0) {
        [...invalidTargetObjects, targetObject].forEach((o) => {
          var _a2;
          (_a2 = Array.isArray(o == null ? void 0 : o.id) ? o == null ? void 0 : o.id : [o == null ? void 0 : o.id]) == null ? void 0 : _a2.forEach((i) => i && targetItems.delete(i));
        });
        const deletes = invalidTargetObjects.filter((io) => typeof io !== "undefined").map(async (io) => {
          await processDelete(io);
        });
        if (targetObject) {
          deletes.push(processDelete(targetObject));
        }
        actions.push(Promise.all(deletes).then(() => process2(sourceObject, ids[0])));
      } else {
        actions.push(process2(sourceObject, ids[0]));
      }
    }
  }
  await Promise.all(actions);
  if (mode === "mirror") {
    if (!sourceHasItems && !allowEmptySource) {
      throw new Error(
        "Source is empty and mode is mirror. This would cause deletion of everything in the target, and most likely indicates an error in source definition."
      );
    }
    const deletes = [];
    targetItems.forEach(async (object) => {
      deletes.push(processDelete(object));
    });
    await Promise.all(deletes);
  }
  await Promise.all([(_a = source.onSyncComplete) == null ? void 0 : _a.call(source, false), (_b = target.onSyncComplete) == null ? void 0 : _b.call(target, true)]);
}
var SyncEngineError = class extends Error {
  constructor(innerError, sourceObject) {
    super(
      `Error syncing ${sourceObject.displayName ?? sourceObject.providerId} (${sourceObject.providerId})
${innerError}`
    );
    this.stack = void 0;
    Object.setPrototypeOf(this, SyncEngineError.prototype);
  }
};

// src/sync/syncEngineConsoleLogger.ts
import { gray, green, red as red2, white, yellow } from "colorette";
function createSyncEngineConsoleLogger(options) {
  const { diffMode = "off", indent, prefix } = options ?? {};
  return function syncEngineConsoleLogger({ action, displayName, whatIf, diff }) {
    let actionTag = "";
    switch (action) {
      case "create":
        actionTag = green("[A]");
        break;
      case "update":
        actionTag = white("[U]");
        break;
      case "delete":
        actionTag = yellow("[D]");
        break;
    }
    let diffString = "";
    if (diffMode === "on" || diffMode === "update" && action === "update") {
      diffString = "\n" + diff.map((change) => {
        if (change.added) {
          return green(change.value);
        }
        if (change.removed) {
          return red2(change.value);
        }
        return change.value;
      }).join("");
    }
    console.log(
      `${indent ?? ""}${whatIf ? gray("[WHATIF]") : ""}${actionTag}${prefix ?? ""} ${displayName}${diffString}`
    );
  };
}

// src/commands/canvas/commands/component/_util.ts
var selectIdentifier = (component) => component.id;
var selectDisplayName = (component) => `${component.name} (pid: ${component.id})`;
var selectSchemaUrl = () => "/schemas/json-schema/component-definition/v1.json";

// src/commands/canvas/commands/component/get.ts
var ComponentGetModule = {
  command: "get <id>",
  describe: "Fetch a component definition",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "Component definition public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getComponentDefinitions({ componentId: id, limit: 1 });
    if (res.componentDefinitions.length === 0) {
      console.error("Component did not exist");
      process.exit(1);
    } else {
      emitWithFormat(
        {
          $schema: new URL(selectSchemaUrl(), apiHost).toString(),
          ...res.componentDefinitions[0]
        },
        format,
        filename
      );
    }
  }
};

// src/commands/canvas/commands/component/list.ts
import { UncachedCanvasClient as UncachedCanvasClient2 } from "@uniformdev/canvas";
var ComponentListModule = {
  command: "list",
  describe: "List component definitions",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.options({
          offset: { describe: "Number of rows to skip before fetching", type: "number", default: 0 },
          limit: { describe: "Number of rows to fetch", type: "number", default: 20 }
        })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, limit, offset, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getComponentDefinitions({ limit, offset });
    emitWithFormat(res.componentDefinitions, format, filename);
  }
};

// src/commands/canvas/commands/component/pull.ts
import { UncachedCanvasClient as UncachedCanvasClient3 } from "@uniformdev/canvas";

// src/commands/canvas/componentDefinitionEngineDataSource.ts
function createComponentDefinitionEngineDataSource({
  client
}) {
  async function* getObjects() {
    const componentDefinitions = paginateAsync(
      async (offset, limit) => (await client.getComponentDefinitions({ limit, offset })).componentDefinitions,
      { pageSize: 100 }
    );
    for await (const def of componentDefinitions) {
      const result = {
        id: selectIdentifier(def),
        displayName: selectDisplayName(def),
        providerId: def.id,
        object: def
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.removeComponentDefinition({ componentId: providerId });
    },
    writeObject: async (object) => {
      await client.updateComponentDefinition({
        componentDefinition: object.object
      });
    }
  };
}

// src/commands/canvas/package.ts
function readCanvasPackage(filename, assertExists) {
  return readUniformPackage(filename, assertExists);
}
function writeCanvasPackage(filename, packageContents) {
  writeUniformPackage(filename, packageContents);
}

// src/commands/canvas/commands/component/pull.ts
var ComponentPullModule = {
  command: "pull <directory>",
  describe: "Pulls all component definitions to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the component definitions to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createComponentDefinitionEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readCanvasPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.components ?? [],
        selectIdentifier,
        selectDisplayName,
        onSyncComplete: async (_, synced) => {
          packageContents.components = synced;
          writeCanvasPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier,
        selectDisplayName,
        selectSchemaUrl: () => new URL(selectSchemaUrl(), apiHost).toString(),
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/component/push.ts
import { UncachedCanvasClient as UncachedCanvasClient4 } from "@uniformdev/canvas";
var ComponentPushModule = {
  command: "push <directory>",
  describe: "Pushes all component definitions from files in a directory to Uniform Canvas",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the component definitions from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readCanvasPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.components ?? [],
        selectIdentifier,
        selectDisplayName
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier,
        selectDisplayName,
        selectSchemaUrl
      });
    }
    const target = createComponentDefinitionEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/component/remove.ts
import { UncachedCanvasClient as UncachedCanvasClient5 } from "@uniformdev/canvas";
var ComponentRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a component definition",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Component definition public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.removeComponentDefinition({ componentId: id });
  }
};

// src/commands/canvas/commands/component/update.ts
import { UncachedCanvasClient as UncachedCanvasClient6 } from "@uniformdev/canvas";
var ComponentUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a component definition",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("filename", { demandOption: true, describe: "Component definition file to put" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.updateComponentDefinition({ componentDefinition: file });
  }
};

// src/commands/canvas/commands/component.ts
var ComponentModule = {
  command: "component <command>",
  aliases: ["def"],
  describe: "Commands for Canvas component definitions",
  builder: (yargs20) => yargs20.command(ComponentPullModule).command(ComponentPushModule).command(ComponentGetModule).command(ComponentRemoveModule).command(ComponentListModule).command(ComponentUpdateModule).demandCommand(),
  handler: () => {
    yargs.help();
  }
};

// src/commands/canvas/commands/composition.ts
import yargs2 from "yargs";

// src/commands/canvas/commands/composition/get.ts
import { UncachedCanvasClient as UncachedCanvasClient7 } from "@uniformdev/canvas";

// src/commands/canvas/util.ts
import { CANVAS_DRAFT_STATE, CANVAS_PUBLISHED_STATE } from "@uniformdev/canvas";
function prepCompositionForDisk(composition) {
  const prepped = {
    ...composition
  };
  delete prepped.projectId;
  delete prepped.state;
  return prepped;
}
function withStateOptions(yargs20) {
  return yargs20.option("state", {
    type: "string",
    describe: `Composition state to fetch.`,
    choices: ["preview", "published"],
    default: "preview"
  });
}
function convertCompositionState(state) {
  const number = Number(state);
  if (!isNaN(number)) {
    return number;
  }
  if (!state) {
    return CANVAS_PUBLISHED_STATE;
  }
  if (typeof state !== "string") {
    throw new Error('state must be "published", "preview", or a number');
  }
  return state === "preview" ? CANVAS_DRAFT_STATE : CANVAS_PUBLISHED_STATE;
}

// src/commands/canvas/commands/composition/get.ts
var CompositionGetModule = {
  command: "get <id>",
  describe: "Fetch a composition",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        withStateOptions(
          yargs20.positional("id", { demandOption: true, describe: "Composition public ID to fetch" }).option({
            resolvePatterns: {
              type: "boolean",
              default: false,
              describe: "Resolve pattern references in the composition"
            },
            resolveOverrides: {
              type: "boolean",
              default: false,
              describe: "Resolves pattern overrides in the composition and removes override definition data"
            },
            componentIDs: {
              type: "boolean",
              default: false,
              describe: "Include individual component UIDs"
            },
            resolveData: {
              type: "boolean",
              default: false,
              describe: "Resolve all data resources used by the composition"
            },
            diagnostics: {
              type: "boolean",
              default: false,
              describe: "Include diagnostics information when resolving data"
            }
          })
        )
      )
    )
  ),
  handler: async ({
    apiHost,
    edgeApiHost,
    apiKey,
    proxy,
    id,
    format,
    filename,
    state,
    project: projectId,
    resolvePatterns,
    resolveOverrides,
    componentIDs,
    resolveData,
    diagnostics
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient7({ apiKey, edgeApiHost, apiHost, fetch: fetch3, projectId });
    const res = prepCompositionForDisk(
      await client.getCompositionById({
        compositionId: id,
        state: convertCompositionState(state),
        skipPatternResolution: !resolvePatterns,
        skipOverridesResolution: !resolveOverrides,
        withComponentIDs: componentIDs,
        skipDataResolution: !resolveData,
        diagnostics
      })
    );
    emitWithFormat(res, format, filename);
  }
};

// src/commands/canvas/commands/composition/list.ts
import { UncachedCanvasClient as UncachedCanvasClient8 } from "@uniformdev/canvas";
var CompositionListModule = {
  command: "list",
  describe: "List compositions",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        withStateOptions(
          yargs20.options({
            offset: { describe: "Number of rows to skip before fetching", type: "number", default: 0 },
            limit: { describe: "Number of rows to fetch", type: "number", default: 20 },
            resolvePatterns: {
              type: "boolean",
              default: false,
              describe: "Resolve pattern references in the composition"
            },
            resolveOverrides: {
              type: "boolean",
              default: false,
              describe: "Resolves pattern overrides in the composition and removes override definition data"
            },
            componentIDs: {
              type: "boolean",
              default: false,
              describe: "Include individual component UIDs"
            }
          })
        )
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    limit,
    offset,
    format,
    filename,
    project: projectId,
    state,
    resolvePatterns,
    resolveOverrides,
    componentIDs
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient8({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getCompositionList({
      limit,
      offset,
      state: convertCompositionState(state),
      skipPatternResolution: !resolvePatterns,
      withComponentIDs: componentIDs,
      skipOverridesResolution: !resolveOverrides
    });
    emitWithFormat(res.compositions, format, filename);
  }
};

// src/commands/canvas/commands/composition/publish.ts
import { UncachedCanvasClient as UncachedCanvasClient9 } from "@uniformdev/canvas";

// src/commands/canvas/commands/composition/_util.ts
var selectIdentifier2 = (component) => component.composition._id;
var selectDisplayName2 = (component) => `${component.composition._name ?? component.composition._slug ?? component.composition._id} (pid: ${component.composition._id})`;

// src/commands/canvas/componentInstanceEngineDataSource.ts
function createComponentInstanceEngineDataSource({
  client,
  state,
  ...clientOptions
}) {
  const stateId = convertCompositionState(state);
  async function* getObjects() {
    const componentInstances = paginateAsync(
      async (offset, limit) => (await client.getCompositionList({
        ...clientOptions,
        limit,
        offset,
        state: stateId,
        skipPatternResolution: true,
        skipOverridesResolution: true,
        withComponentIDs: true
      })).compositions,
      { pageSize: 100 }
    );
    for await (const compositionListItem of componentInstances) {
      const result = {
        id: selectIdentifier2(compositionListItem),
        displayName: selectDisplayName2(compositionListItem),
        providerId: compositionListItem.composition._id,
        object: prepCompositionForDisk(compositionListItem)
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.removeComposition({ compositionId: providerId });
    },
    writeObject: async (object) => {
      await client.updateComposition({ ...object.object, state: stateId });
    }
  };
}

// src/commands/canvas/commands/composition/publish.ts
var CompositionPublishModule = {
  command: "publish [compositionIDs]",
  describe: "Publishes compositions",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("compositionIDs", {
          describe: "Publishes composition(s) by ID. Comma-separate multiple IDs. Use --all to publish all instead.",
          type: "string"
        }).option("all", {
          alias: ["a"],
          describe: "Publishes all compositions. Use compositionId to publish one instead.",
          default: false,
          type: "boolean"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but does not perform any publishing",
          default: false,
          type: "boolean"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    compositionIDs,
    all,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    if (!all && !compositionIDs || all && compositionIDs) {
      console.error(`Specify --all or composition ID(s) to publish.`);
      process.exit(1);
    }
    const compositionIDsArray = compositionIDs ? compositionIDs.split(",").map((id) => id.trim()) : void 0;
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient9({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createComponentInstanceEngineDataSource({
      client,
      state: "preview",
      compositionIDs: compositionIDsArray
    });
    const target = createComponentInstanceEngineDataSource({
      client,
      state: "published",
      compositionIDs: compositionIDsArray
    });
    await syncEngine({
      source,
      target,
      mode: "mirror",
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/composition/pull.ts
import { UncachedCanvasClient as UncachedCanvasClient10 } from "@uniformdev/canvas";
var CompositionPullModule = {
  command: "pull <directory>",
  describe: "Pulls all compositions to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withStateOptions(
        withDiffOptions(
          yargs20.positional("directory", {
            describe: "Directory to save the component definitions to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
            type: "string"
          }).option("format", {
            alias: ["f"],
            describe: "Output format",
            default: "yaml",
            choices: ["yaml", "json"],
            type: "string"
          }).option("what-if", {
            alias: ["w"],
            describe: "What-if mode reports what would be done but changes no files",
            default: false,
            type: "boolean"
          }).option("mode", {
            alias: ["m"],
            describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
            choices: ["create", "createOrUpdate", "mirror"],
            default: "mirror",
            type: "string"
          })
        )
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    state,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient10({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createComponentInstanceEngineDataSource({ client, state });
    const isPackage = isPathAPackageFile(directory);
    let target;
    if (isPackage) {
      const packageContents = readCanvasPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: (packageContents == null ? void 0 : packageContents.compositions) ?? [],
        selectIdentifier: selectIdentifier2,
        selectDisplayName: selectDisplayName2,
        onSyncComplete: async (_, synced) => {
          packageContents.compositions = synced;
          writeCanvasPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier2,
        selectDisplayName: selectDisplayName2,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/composition/push.ts
import { UncachedCanvasClient as UncachedCanvasClient11 } from "@uniformdev/canvas";
var CompositionPushModule = {
  command: "push <directory>",
  describe: "Pushes all compositions from files in a directory to Uniform Canvas",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withStateOptions(
        withDiffOptions(
          yargs20.positional("directory", {
            describe: "Directory to read the component definitions from. If a filename is used, a package will be read instead.",
            type: "string"
          }).option("what-if", {
            alias: ["w"],
            describe: "What-if mode reports what would be done but changes nothing",
            default: false,
            type: "boolean"
          }).option("mode", {
            alias: ["m"],
            describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
            choices: ["create", "createOrUpdate", "mirror"],
            default: "mirror",
            type: "string"
          })
        )
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    state,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient11({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readCanvasPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.compositions ?? [],
        selectIdentifier: selectIdentifier2,
        selectDisplayName: selectDisplayName2
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier2,
        selectDisplayName: selectDisplayName2
      });
    }
    const target = createComponentInstanceEngineDataSource({ client, state });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/composition/remove.ts
import { UncachedCanvasClient as UncachedCanvasClient12 } from "@uniformdev/canvas";
var CompositionRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a composition",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Composition public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient12({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.removeComposition({ compositionId: id });
  }
};

// src/commands/canvas/commands/composition/unpublish.ts
import { CANVAS_PUBLISHED_STATE as CANVAS_PUBLISHED_STATE2, UncachedCanvasClient as UncachedCanvasClient13 } from "@uniformdev/canvas";
var CompositionUnpublishModule = {
  command: "unpublish <id>",
  describe: "Unpublish a composition",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Composition public ID to unpublish" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient13({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.removeComposition({ compositionId: id, state: CANVAS_PUBLISHED_STATE2 });
  }
};

// src/commands/canvas/commands/composition/update.ts
import { UncachedCanvasClient as UncachedCanvasClient14 } from "@uniformdev/canvas";
var CompositionUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a composition",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withStateOptions(
        yargs20.positional("filename", { demandOption: true, describe: "Composition file to put" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId, state }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedCanvasClient14({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.updateComposition({ ...file, state: convertCompositionState(state) });
  }
};

// src/commands/canvas/commands/composition.ts
var CompositionModule = {
  command: "composition <command>",
  describe: "Commands for Canvas compositions",
  aliases: ["comp"],
  builder: (yargs20) => yargs20.command(CompositionPullModule).command(CompositionPushModule).command(CompositionGetModule).command(CompositionRemoveModule).command(CompositionListModule).command(CompositionUpdateModule).command(CompositionPublishModule).command(CompositionUnpublishModule).demandCommand(),
  handler: () => {
    yargs2.help();
  }
};

// src/commands/canvas/commands/dataType.ts
import yargs3 from "yargs";

// src/commands/canvas/commands/dataType/get.ts
import { DataTypeClient } from "@uniformdev/canvas";
var DataTypeGetModule = {
  command: "get <id>",
  describe: "Get a data type",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        yargs20.positional("id", { demandOption: true, describe: "Data type public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new DataTypeClient({ apiKey, apiHost, fetch: fetch3, projectId, bypassCache: true });
    const res = await client.get();
    const found = res.results.find((f) => f.id === id);
    if (!found) {
      throw new Error(`Data type with ID ${id} not found`);
    }
    emitWithFormat(found, format, filename);
  }
};

// src/commands/canvas/commands/dataType/list.ts
import { DataTypeClient as DataTypeClient2 } from "@uniformdev/canvas";
var DataTypeListModule = {
  command: "list",
  describe: "List data types",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new DataTypeClient2({ apiKey, apiHost, fetch: fetch3, projectId, bypassCache: true });
    const res = await client.get();
    emitWithFormat(res.results, format, filename);
  }
};

// src/commands/canvas/commands/dataType/pull.ts
import { DataTypeClient as DataTypeClient3 } from "@uniformdev/canvas";

// src/commands/canvas/commands/dataType/_util.ts
var selectIdentifier3 = (dataType) => dataType.id;
var selectDisplayName3 = (dataType) => `${dataType.displayName} (pid: ${dataType.id})`;

// src/commands/canvas/dataTypeEngineDataSource.ts
function createDataTypeEngineDataSource({
  client
}) {
  async function* getObjects() {
    const dataTypes = (await client.get()).results;
    for await (const dataType of dataTypes) {
      const result = {
        id: selectIdentifier3(dataType),
        displayName: selectDisplayName3(dataType),
        providerId: dataType.id,
        object: dataType
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.remove({ typeId: providerId });
    },
    writeObject: async (object) => {
      await client.upsert({
        data: object.object
      });
    }
  };
}

// src/commands/canvas/commands/dataType/pull.ts
var DataTypePullModule = {
  command: "pull <directory>",
  describe: "Pulls all data types to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the data types to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new DataTypeClient3({
      apiKey,
      apiHost,
      fetch: fetch3,
      projectId,
      bypassCache: true
    });
    const source = createDataTypeEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readCanvasPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.dataTypes ?? [],
        selectIdentifier: selectIdentifier3,
        selectDisplayName: selectDisplayName3,
        onSyncComplete: async (_, synced) => {
          packageContents.dataTypes = synced;
          writeCanvasPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier3,
        selectDisplayName: selectDisplayName3,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/dataType/push.ts
import { DataTypeClient as DataTypeClient4 } from "@uniformdev/canvas";
var DataTypePushModule = {
  command: "push <directory>",
  describe: "Pushes all data types from files in a directory to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the data types from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new DataTypeClient4({
      apiKey,
      apiHost,
      fetch: fetch3,
      projectId,
      bypassCache: true
    });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readCanvasPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.dataTypes ?? [],
        selectIdentifier: selectIdentifier3,
        selectDisplayName: selectDisplayName3
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier3,
        selectDisplayName: selectDisplayName3
      });
    }
    const target = createDataTypeEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/canvas/commands/dataType/remove.ts
import { DataTypeClient as DataTypeClient5 } from "@uniformdev/canvas";
var DataTypeRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a data type",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Data type public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new DataTypeClient5({ apiKey, apiHost, fetch: fetch3, projectId, bypassCache: true });
    await client.remove({ typeId: id });
  }
};

// src/commands/canvas/commands/dataType/update.ts
import { DataTypeClient as DataTypeClient6 } from "@uniformdev/canvas";
var DataTypeUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a data type",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("filename", { demandOption: true, describe: "Data type file to put" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new DataTypeClient6({ apiKey, apiHost, fetch: fetch3, projectId, bypassCache: true });
    const file = readFileToObject(filename);
    await client.upsert({ data: file });
  }
};

// src/commands/canvas/commands/dataType.ts
var DataTypeModule = {
  command: "datatype <command>",
  aliases: ["dt"],
  describe: "Commands for Data Type definitions",
  builder: (yargs20) => yargs20.command(DataTypeGetModule).command(DataTypePullModule).command(DataTypePushModule).command(DataTypeRemoveModule).command(DataTypeListModule).command(DataTypeUpdateModule).demandCommand(),
  handler: () => {
    yargs3.help();
  }
};

// src/commands/canvas/index.ts
var CanvasCommand = {
  command: "canvas <command>",
  aliases: ["cv", "pm", "presentation"],
  describe: "Uniform Canvas commands",
  builder: (yargs20) => yargs20.command(CompositionModule).command(ComponentModule).command(DataTypeModule).demandCommand(),
  handler: () => {
    yargs4.showHelp();
  }
};

// src/commands/context/index.ts
import yargs11 from "yargs";

// src/commands/context/commands/aggregate.ts
import yargs5 from "yargs";

// src/commands/context/commands/aggregate/get.ts
import { UncachedAggregateClient } from "@uniformdev/context/api";
var AggregateGetModule = {
  command: "get <id>",
  describe: "Fetch an aggregate",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "Aggregate public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedAggregateClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get({ aggregateId: id });
    if (res.aggregates.length === 0) {
      console.error("Aggregate did not exist");
      process.exit(1);
    } else {
      emitWithFormat(res.aggregates[0], format, filename);
    }
  }
};

// src/commands/context/commands/aggregate/list.ts
import { UncachedAggregateClient as UncachedAggregateClient2 } from "@uniformdev/context/api";
var AggregateListModule = {
  command: "list",
  describe: "List aggregates",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedAggregateClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get({});
    emitWithFormat(res.aggregates, format, filename);
  }
};

// src/commands/context/commands/aggregate/pull.ts
import { UncachedAggregateClient as UncachedAggregateClient3 } from "@uniformdev/context/api";

// src/commands/context/commands/aggregate/_util.ts
var selectIdentifier4 = (source) => source.id;
var selectDisplayName4 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/context/aggregateEngineDataSource.ts
function createAggregateEngineDataSource({
  client,
  type
}) {
  async function* getObjects() {
    const aggregates = (await client.get({ type })).aggregates;
    for await (const def of aggregates) {
      const result = {
        id: selectIdentifier4(def),
        displayName: selectDisplayName4(def),
        providerId: def.id,
        object: def
      };
      yield result;
    }
  }
  const writtenObjects = [];
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.remove({ aggregateId: providerId });
    },
    writeObject: async (object) => {
      await client.upsert({
        aggregate: object.object,
        skipInputs: true
      });
      writtenObjects.push(object.object);
    },
    complete: async () => {
      await Promise.all(
        writtenObjects.map((object) => client.upsert({ aggregate: object, skipInputs: false }))
      );
    }
  };
}

// src/commands/context/package.ts
function readContextPackage(filename, assertExists) {
  return readUniformPackage(filename, assertExists);
}
function writeContextPackage(filename, packageContents) {
  writeUniformPackage(filename, packageContents);
}

// src/commands/context/commands/aggregate/pull.ts
var AggregatePullModule = {
  command: "pull <directory>",
  describe: "Pulls all aggregates to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the aggregates to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedAggregateClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createAggregateEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.aggregates ?? [],
        selectIdentifier: selectIdentifier4,
        selectDisplayName: selectDisplayName4,
        onSyncComplete: async (_, synced) => {
          packageContents.aggregates = synced;
          writeContextPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier4,
        selectDisplayName: selectDisplayName4,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/aggregate/push.ts
import { UncachedAggregateClient as UncachedAggregateClient4 } from "@uniformdev/context/api";
var AggregatePushModule = {
  command: "push <directory>",
  describe: "Pushes all aggregates from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the aggregates from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedAggregateClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.aggregates ?? [],
        selectIdentifier: selectIdentifier4,
        selectDisplayName: selectDisplayName4
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier4,
        selectDisplayName: selectDisplayName4
      });
    }
    const target = createAggregateEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
    await target.complete();
  }
};

// src/commands/context/commands/aggregate/remove.ts
import { UncachedAggregateClient as UncachedAggregateClient5 } from "@uniformdev/context/api";
var AggregateRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete an aggregate",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Aggregate public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedAggregateClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.remove({ aggregateId: id });
  }
};

// src/commands/context/commands/aggregate/update.ts
import { UncachedAggregateClient as UncachedAggregateClient6 } from "@uniformdev/context/api";
var AggregateUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update an aggregate",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("filename", { demandOption: true, describe: "Aggregate file to put" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedAggregateClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsert({ aggregate: file });
  }
};

// src/commands/context/commands/aggregate.ts
var AggregateModule = {
  command: "aggregate <command>",
  aliases: ["agg", "intent", "audience"],
  describe: "Commands for Context aggregates (intents, audiences)",
  builder: (yargs20) => yargs20.command(AggregatePullModule).command(AggregatePushModule).command(AggregateGetModule).command(AggregateRemoveModule).command(AggregateListModule).command(AggregateUpdateModule).demandCommand(),
  handler: () => {
    yargs5.help();
  }
};

// src/commands/context/commands/enrichment.ts
import yargs6 from "yargs";

// src/commands/context/commands/enrichment/get.ts
import { UncachedEnrichmentClient } from "@uniformdev/context/api";
var EnrichmentGetModule = {
  command: "get <id>",
  describe: "Fetch an enrichment category and its values",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "Enrichment category public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    var _a, _b;
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedEnrichmentClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = (_b = (_a = await client.get()) == null ? void 0 : _a.enrichments) == null ? void 0 : _b.filter((enr) => enr.id === id);
    if (res.length === 0) {
      console.error("Enrichment did not exist");
      process.exit(1);
    } else {
      emitWithFormat(res[0], format, filename);
    }
  }
};

// src/commands/context/commands/enrichment/list.ts
import { UncachedEnrichmentClient as UncachedEnrichmentClient2 } from "@uniformdev/context/api";
var EnrichmentListModule = {
  command: "list",
  describe: "List enrichments",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedEnrichmentClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get();
    emitWithFormat(res.enrichments, format, filename);
  }
};

// src/commands/context/commands/enrichment/pull.ts
import { UncachedEnrichmentClient as UncachedEnrichmentClient3 } from "@uniformdev/context/api";

// src/commands/context/commands/enrichment/_util.ts
var selectIdentifier5 = (source) => source.id;
var selectDisplayName5 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/context/enrichmentEngineDataSource.ts
function createEnrichmentEngineDataSource({
  client
}) {
  async function* getObjects() {
    const enrichments = (await client.get()).enrichments;
    for await (const def of enrichments) {
      const result = {
        id: selectIdentifier5(def),
        displayName: selectDisplayName5(def),
        providerId: def.id,
        object: def
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.removeCategory({ enrichmentId: providerId });
    },
    writeObject: async (object, existingObject) => {
      var _a;
      await client.upsertCategory({
        enrichment: object.object
      });
      const source = createEnrichmentValueEngineDataSource({
        categoryId: object.id,
        values: object.object.values
      });
      const target = createEnrichmentValueEngineDataSource({
        categoryId: object.id,
        values: ((_a = existingObject == null ? void 0 : existingObject.object) == null ? void 0 : _a.values) ?? [],
        client
      });
      await syncEngine({
        source,
        target,
        mode: "mirror",
        whatIf: false,
        log: createSyncEngineConsoleLogger({
          diffMode: "off",
          prefix: ` ${object.displayName} value`,
          indent: "> "
        })
      });
    }
  };
}
var createEnrichmentValueEngineDataSource = ({
  client,
  categoryId,
  values
}) => {
  const iterator = async function* () {
    for (const value of values) {
      yield {
        id: value.id,
        providerId: value.id,
        object: value,
        displayName: `${value.value} (pid: ${value.id})`
      };
    }
  };
  return {
    objects: iterator(),
    deleteObject: async (providerId) => {
      if (!client) {
        throw new Error("Provider is read only");
      }
      await client.removeValue({ enrichmentId: categoryId, enrichmentValueId: providerId });
    },
    writeObject: async (object) => {
      if (!client) {
        throw new Error("Provider is read only");
      }
      await client.upsertValue({ enrichmentId: categoryId, enrichmentValue: object.object });
    }
  };
};

// src/commands/context/commands/enrichment/pull.ts
var EnrichmentPullModule = {
  command: "pull <directory>",
  describe: "Pulls all enrichments to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the enrichments to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedEnrichmentClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createEnrichmentEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.enrichments ?? [],
        selectIdentifier: selectIdentifier5,
        selectDisplayName: selectDisplayName5,
        onSyncComplete: async (_, synced) => {
          packageContents.enrichments = synced;
          writeContextPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier5,
        selectDisplayName: selectDisplayName5,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/enrichment/push.ts
import { UncachedEnrichmentClient as UncachedEnrichmentClient4 } from "@uniformdev/context/api";
var EnrichmentPushModule = {
  command: "push <directory>",
  describe: "Pushes all enrichments from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the enrichments from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedEnrichmentClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.enrichments ?? [],
        selectIdentifier: selectIdentifier5,
        selectDisplayName: selectDisplayName5
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier5,
        selectDisplayName: selectDisplayName5
      });
    }
    const target = createEnrichmentEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/enrichment/remove.ts
import { UncachedEnrichmentClient as UncachedEnrichmentClient5 } from "@uniformdev/context/api";
var EnrichmentRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete an enrichment category and its values",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Enrichment category public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedEnrichmentClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.removeCategory({ enrichmentId: id });
  }
};

// src/commands/context/commands/enrichment.ts
var EnrichmentModule = {
  command: "enrichment <command>",
  aliases: ["enr"],
  describe: "Commands for Context enrichments",
  builder: (yargs20) => yargs20.command(EnrichmentPullModule).command(EnrichmentPushModule).command(EnrichmentGetModule).command(EnrichmentRemoveModule).command(EnrichmentListModule).demandCommand(),
  handler: () => {
    yargs6.help();
  }
};

// src/commands/context/commands/manifest.ts
import yargs7 from "yargs";

// src/commands/context/commands/manifest/get.ts
import { ApiClientError, UncachedManifestClient } from "@uniformdev/context/api";
import { gray as gray2, green as green2, red as red3 } from "colorette";
import { writeFile } from "fs";
import { exit } from "process";
var ManifestGetModule = {
  command: "get [output]",
  aliases: ["dl", "download"],
  describe: "Download the Uniform Context manifest for a project",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.option("preview", {
        describe: "If set, fetches the unpublished preview manifest (The API key must have permission)",
        default: false,
        type: "boolean",
        alias: ["d"]
      }).option("output", {
        string: true,
        alias: "o",
        default: process.env.UNIFORM_MANIFEST_PATH,
        describe: "Path to write manifest to. Defaults to UNIFORM_MANIFEST_PATH env if set.",
        demandOption: true
      })
    )
  ),
  handler: async ({ apiKey, apiHost, proxy, output, project, preview }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedManifestClient({
      apiHost,
      projectId: project,
      apiKey,
      fetch: fetch3
    });
    try {
      const manifest = await client.get({ preview });
      const text = JSON.stringify(manifest, null, 2);
      if (output) {
        writeFile(output, text, (error) => {
          if (error) {
            console.error(`Error writing file to ${output}
`, error);
            exit(1);
          }
          console.log(green2(`\u2705 ${output} has been updated from ${apiHost}`));
        });
      } else {
        console.log(text);
      }
    } catch (e) {
      let message;
      if (e instanceof ApiClientError) {
        if (e.statusCode === 403) {
          message = `The API key ${apiKey} did not have permissions to fetch the manifest. Ensure ${preview ? "Uniform Context > Read Drafts" : "Uniform Context > Manifest > Read"} permissions are granted.`;
        }
        message = e.message;
      } else {
        message = e.toString();
      }
      console.error(red3(`\u26A0 Error fetching Context manifest`));
      console.error(gray2(`  \u2757 ${message}`));
      exit(1);
    }
  }
};

// src/commands/context/commands/manifest/publish.ts
import { ApiClientError as ApiClientError2, UncachedManifestClient as UncachedManifestClient2 } from "@uniformdev/context/api";
import { gray as gray3, red as red4 } from "colorette";
import { exit as exit2 } from "process";
var ManifestPublishModule = {
  command: "publish",
  describe: "Publish the Uniform Context manifest for a project",
  builder: (yargs20) => withApiOptions(withProjectOptions(yargs20)),
  handler: async ({ apiKey, apiHost, proxy, project }) => {
    const fetch3 = nodeFetchProxy(proxy);
    try {
      const client = new UncachedManifestClient2({
        apiHost,
        projectId: project,
        apiKey,
        fetch: fetch3
      });
      await client.publish();
    } catch (e) {
      let message;
      if (e instanceof ApiClientError2) {
        if (e.statusCode === 403) {
          message = `The API key ${apiKey} did not have permissions to publish the manifest. Ensure Uniform Context > Manifest > Publish permissions are granted.`;
        }
        message = e.message;
      } else {
        message = e.toString();
      }
      console.error(red4(`\u26A0 Error publishing Context manifest`));
      console.error(gray3(`  \u2757 ${message}`));
      exit2(1);
    }
  }
};

// src/commands/context/commands/manifest.ts
var ManifestModule = {
  command: "manifest <command>",
  describe: "Commands for context manifests",
  aliases: ["man"],
  builder: (yargs20) => yargs20.command(ManifestGetModule).command(ManifestPublishModule).demandCommand(),
  handler: () => {
    yargs7.help();
  }
};

// src/commands/context/commands/quirk.ts
import yargs8 from "yargs";

// src/commands/context/commands/quirk/get.ts
import { UncachedQuirkClient } from "@uniformdev/context/api";
var QuirkGetModule = {
  command: "get <id>",
  describe: "Fetch a quirk",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "Quirk public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedQuirkClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get({ quirkId: id, withIntegrations: true });
    if (res.quirks.length === 0) {
      console.error("Quirk did not exist");
      process.exit(1);
    } else {
      emitWithFormat(res.quirks[0], format, filename);
    }
  }
};

// src/commands/context/commands/quirk/list.ts
import { UncachedQuirkClient as UncachedQuirkClient2 } from "@uniformdev/context/api";
var QuirkListModule = {
  command: "list",
  describe: "List quirks",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.option("withIntegrations", {
          alias: ["i"],
          describe: "Whether to include meta-quirks created by integrations in the list. Defaults to false.",
          type: "boolean"
        })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId, withIntegrations }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedQuirkClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get({ withIntegrations });
    emitWithFormat(res.quirks, format, filename);
  }
};

// src/commands/context/commands/quirk/pull.ts
import { UncachedQuirkClient as UncachedQuirkClient3 } from "@uniformdev/context/api";

// src/commands/context/commands/quirk/_util.ts
var selectIdentifier6 = (source) => source.id;
var selectDisplayName6 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/context/quirkEngineDataSource.ts
function createQuirkEngineDataSource({
  client
}) {
  async function* getObjects() {
    const quirks = (await client.get({ withIntegrations: false })).quirks;
    for await (const def of quirks) {
      const result = {
        id: selectIdentifier6(def),
        displayName: selectDisplayName6(def),
        providerId: def.id,
        object: def
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.remove({ quirkId: providerId });
    },
    writeObject: async (object) => {
      await client.upsert({
        quirk: object.object
      });
    }
  };
}

// src/commands/context/commands/quirk/pull.ts
var QuirkPullModule = {
  command: "pull <directory>",
  describe: "Pulls all quirks to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the quirks to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedQuirkClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createQuirkEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.quirks ?? [],
        selectIdentifier: selectIdentifier6,
        selectDisplayName: selectDisplayName6,
        onSyncComplete: async (_, synced) => {
          packageContents.quirks = synced;
          writeContextPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier6,
        selectDisplayName: selectDisplayName6,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/quirk/push.ts
import { UncachedQuirkClient as UncachedQuirkClient4 } from "@uniformdev/context/api";
var QuirkPushModule = {
  command: "push <directory>",
  describe: "Pushes all quirks from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the quirks from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedQuirkClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.quirks ?? [],
        selectIdentifier: selectIdentifier6,
        selectDisplayName: selectDisplayName6
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier6,
        selectDisplayName: selectDisplayName6
      });
    }
    const target = createQuirkEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/quirk/remove.ts
import { UncachedQuirkClient as UncachedQuirkClient5 } from "@uniformdev/context/api";
var QuirkRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a quirk",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Quirk public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedQuirkClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.remove({ quirkId: id });
  }
};

// src/commands/context/commands/quirk/update.ts
import { UncachedQuirkClient as UncachedQuirkClient6 } from "@uniformdev/context/api";
var QuirkUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a quirk",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(yargs20.positional("filename", { demandOption: true, describe: "Quirk file to put" }))
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedQuirkClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsert({ quirk: file });
  }
};

// src/commands/context/commands/quirk.ts
var QuirkModule = {
  command: "quirk <command>",
  aliases: ["qk"],
  describe: "Commands for Context quirks",
  builder: (yargs20) => yargs20.command(QuirkPullModule).command(QuirkPushModule).command(QuirkGetModule).command(QuirkRemoveModule).command(QuirkListModule).command(QuirkUpdateModule).demandCommand(),
  handler: () => {
    yargs8.help();
  }
};

// src/commands/context/commands/signal.ts
import yargs9 from "yargs";

// src/commands/context/commands/signal/get.ts
import { UncachedSignalClient } from "@uniformdev/context/api";
var SignalGetModule = {
  command: "get <id>",
  describe: "Fetch a signal",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "Signal public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedSignalClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get({ signalId: id });
    if (res.signals.length === 0) {
      console.error("Signal did not exist");
      process.exit(1);
    } else {
      emitWithFormat(res.signals[0], format, filename);
    }
  }
};

// src/commands/context/commands/signal/list.ts
import { UncachedSignalClient as UncachedSignalClient2 } from "@uniformdev/context/api";
var SignalListModule = {
  command: "list",
  describe: "List signals",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedSignalClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get();
    emitWithFormat(res.signals, format, filename);
  }
};

// src/commands/context/commands/signal/pull.ts
import { UncachedSignalClient as UncachedSignalClient3 } from "@uniformdev/context/api";

// src/commands/context/commands/signal/_util.ts
var selectIdentifier7 = (source) => source.id;
var selectDisplayName7 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/context/signalEngineDataSource.ts
function createSignalEngineDataSource({
  client
}) {
  async function* getObjects() {
    const signals = (await client.get()).signals;
    for await (const def of signals) {
      const result = {
        id: selectIdentifier7(def),
        displayName: selectDisplayName7(def),
        providerId: def.id,
        object: def
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.remove({ signalId: providerId });
    },
    writeObject: async (object) => {
      await client.upsert({
        signal: object.object
      });
    }
  };
}

// src/commands/context/commands/signal/pull.ts
var SignalPullModule = {
  command: "pull <directory>",
  describe: "Pulls all signals to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the signals to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedSignalClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createSignalEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.signals ?? [],
        selectIdentifier: selectIdentifier7,
        selectDisplayName: selectDisplayName7,
        onSyncComplete: async (_, synced) => {
          packageContents.signals = synced;
          writeContextPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier7,
        selectDisplayName: selectDisplayName7,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/signal/push.ts
import { UncachedSignalClient as UncachedSignalClient4 } from "@uniformdev/context/api";
var SignalPushModule = {
  command: "push <directory>",
  describe: "Pushes all signals from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the signals from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedSignalClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.signals ?? [],
        selectIdentifier: selectIdentifier7,
        selectDisplayName: selectDisplayName7
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier7,
        selectDisplayName: selectDisplayName7
      });
    }
    const target = createSignalEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/signal/remove.ts
import { UncachedSignalClient as UncachedSignalClient5 } from "@uniformdev/context/api";
var SignalRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a signal",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "Signal public ID to delete" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedSignalClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.remove({ signalId: id });
  }
};

// src/commands/context/commands/signal/update.ts
import { UncachedSignalClient as UncachedSignalClient6 } from "@uniformdev/context/api";
var SignalUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a signal",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(yargs20.positional("filename", { demandOption: true, describe: "Signal file to put" }))
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedSignalClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsert({ signal: file });
  }
};

// src/commands/context/commands/signal.ts
var SignalModule = {
  command: "signal <command>",
  aliases: ["sig"],
  describe: "Commands for Context signals",
  builder: (yargs20) => yargs20.command(SignalPullModule).command(SignalPushModule).command(SignalGetModule).command(SignalRemoveModule).command(SignalListModule).command(SignalUpdateModule).demandCommand(),
  handler: () => {
    yargs9.help();
  }
};

// src/commands/context/commands/test.ts
import yargs10 from "yargs";

// src/commands/context/commands/test/get.ts
import { UncachedTestClient } from "@uniformdev/context/api";
var TestGetModule = {
  command: "get <id>",
  describe: "Fetch a test",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "Test public ID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedTestClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get({ testId: id });
    if (res.tests.length === 0) {
      console.error("Test did not exist");
      process.exit(1);
    } else {
      emitWithFormat(res.tests[0], format, filename);
    }
  }
};

// src/commands/context/commands/test/list.ts
import { UncachedTestClient as UncachedTestClient2 } from "@uniformdev/context/api";
var TestListModule = {
  command: "list",
  describe: "List tests",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedTestClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.get();
    emitWithFormat(res.tests, format, filename);
  }
};

// src/commands/context/commands/test/pull.ts
import { UncachedTestClient as UncachedTestClient3 } from "@uniformdev/context/api";

// src/commands/context/commands/test/_util.ts
var selectIdentifier8 = (source) => source.id;
var selectDisplayName8 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/context/testEngineDataSource.ts
function createTestEngineDataSource({
  client
}) {
  async function* getObjects() {
    const tests = (await client.get()).tests;
    for await (const def of tests) {
      const result = {
        id: selectIdentifier8(def),
        displayName: selectDisplayName8(def),
        providerId: def.id,
        object: def
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.remove({ testId: providerId });
    },
    writeObject: async (object) => {
      await client.upsert({
        test: object.object
      });
    }
  };
}

// src/commands/context/commands/test/pull.ts
var TestPullModule = {
  command: "pull <directory>",
  describe: "Pulls all tests to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save the tests to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedTestClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createTestEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.tests ?? [],
        selectIdentifier: selectIdentifier8,
        selectDisplayName: selectDisplayName8,
        onSyncComplete: async (_, synced) => {
          packageContents.tests = synced;
          writeContextPackage(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier8,
        selectDisplayName: selectDisplayName8,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/test/push.ts
import { UncachedTestClient as UncachedTestClient4 } from "@uniformdev/context/api";
var TestPushModule = {
  command: "push <directory>",
  describe: "Pushes all tests from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read the tests from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedTestClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.tests ?? [],
        selectIdentifier: selectIdentifier8,
        selectDisplayName: selectDisplayName8
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier8,
        selectDisplayName: selectDisplayName8
      });
    }
    const target = createTestEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/context/commands/test/remove.ts
import { UncachedTestClient as UncachedTestClient5 } from "@uniformdev/context/api";
var TestRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a test",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(yargs20.positional("id", { demandOption: true, describe: "Test public ID to delete" }))
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedTestClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.remove({ testId: id });
  }
};

// src/commands/context/commands/test/update.ts
import { UncachedTestClient as UncachedTestClient6 } from "@uniformdev/context/api";
var TestUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a test",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(yargs20.positional("filename", { demandOption: true, describe: "Test file to put" }))
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedTestClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsert({ test: file });
  }
};

// src/commands/context/commands/test.ts
var TestModule = {
  command: "test <command>",
  describe: "Commands for Context A/B tests",
  builder: (yargs20) => yargs20.command(TestPullModule).command(TestPushModule).command(TestGetModule).command(TestRemoveModule).command(TestListModule).command(TestUpdateModule).demandCommand(),
  handler: () => {
    yargs10.help();
  }
};

// src/commands/context/index.ts
var ContextCommand = {
  command: "context <command>",
  aliases: ["ctx"],
  describe: "Uniform Context commands",
  builder: (yargs20) => yargs20.command(ManifestModule).command(SignalModule).command(EnrichmentModule).command(AggregateModule).command(QuirkModule).command(TestModule).demandCommand(),
  handler: () => {
    yargs11.showHelp();
  }
};

// src/spinner.ts
import ora from "ora";
var makeSpinner = () => {
  const spinners = [];
  const stopAllSpinners = () => spinners.forEach((spinner) => spinner.stop());
  const spin = async (text) => {
    const spinner = ora(text).start();
    spinners.push(spinner);
    const minWait = new Promise((resolve) => setTimeout(resolve, 500));
    return async () => {
      await minWait;
      spinner.stop();
    };
  };
  return { stopAllSpinners, spin };
};

// src/telemetry/telemetry.ts
import crypto from "crypto";
import { PostHog } from "posthog-node";

// package.json
var package_default = {
  name: "@uniformdev/cli",
  version: "19.15.0",
  description: "Uniform command line interface tool",
  license: "SEE LICENSE IN LICENSE.txt",
  main: "./cli.js",
  types: "./dist/index.d.ts",
  sideEffects: false,
  scripts: {
    uniform: "node ./cli.js",
    build: "tsup",
    dev: "tsup --watch",
    clean: "rimraf dist",
    test: "jest --maxWorkers=1 --passWithNoTests",
    lint: 'eslint "src/**/*.{js,ts,tsx}"',
    format: 'prettier --write "src/**/*.{js,ts,tsx}"'
  },
  dependencies: {
    "@uniformdev/canvas": "workspace:*",
    "@uniformdev/context": "workspace:*",
    "@uniformdev/project-map": "workspace:*",
    "@uniformdev/redirect": "workspace:*",
    colorette: "2.0.20",
    diff: "^5.0.0",
    dotenv: "^16.0.3",
    execa: "5.1.1",
    "fs-jetpack": "5.1.0",
    graphql: "16.6.0",
    "graphql-request": "6.0.0",
    "https-proxy-agent": "^5.0.1",
    inquirer: "9.2.5",
    "isomorphic-git": "1.21.0",
    "isomorphic-unfetch": "^3.1.0",
    "js-yaml": "^4.1.0",
    jsonwebtoken: "9.0.0",
    "lodash.isequalwith": "^4.4.0",
    open: "9.1.0",
    ora: "6.3.1",
    "posthog-node": "3.1.1",
    slugify: "1.6.6",
    yargs: "^17.6.2",
    zod: "3.21.4"
  },
  devDependencies: {
    "@types/diff": "5.0.3",
    "@types/inquirer": "9.0.3",
    "@types/js-yaml": "4.0.5",
    "@types/jsonwebtoken": "9.0.2",
    "@types/lodash.isequalwith": "4.4.7",
    "@types/node": "18.16.16",
    "@types/yargs": "17.0.24"
  },
  bin: {
    uniform: "./cli.js"
  },
  files: [
    "/dist"
  ],
  publishConfig: {
    access: "public"
  }
};

// src/telemetry/telemetry.ts
var POSTHOG_WRITE_ONLY_KEY = "phc_c8YoKI9984KOHBfNrCRfIKvL56aYd5OpYxOdYexRzH7";
var Telemetry = class {
  constructor(prefix, disable = false) {
    this.prefix = prefix;
    this.distinctId = crypto.randomBytes(20).toString("hex");
    if (!disable) {
      this.posthog = new PostHog(POSTHOG_WRITE_ONLY_KEY, {
        flushAt: 1,
        flushInterval: 1
      });
      this.send("started");
    }
  }
  login(sub, user) {
    if (!this.posthog) {
      return;
    }
    const alias = this.distinctId;
    this.distinctId = sub;
    this.posthog.alias({ distinctId: this.distinctId, alias });
    this.posthog.identify({
      distinctId: this.distinctId,
      properties: {
        email: user.email_address,
        sub,
        teamCount: user.teams.length
      }
    });
    this.send("logged in");
  }
  send(event, properties = {}) {
    var _a;
    (_a = this.posthog) == null ? void 0 : _a.capture({
      distinctId: this.distinctId,
      event: [this.prefix, event].join(" "),
      properties: {
        version: package_default.version,
        ...properties
      }
    });
  }
  shutdown() {
    var _a;
    this.send("exited", { exitCode: process.exitCode });
    return (_a = this.posthog) == null ? void 0 : _a.shutdownAsync();
  }
};

// src/commands/new/commands/new.ts
import inquirer4 from "inquirer";

// src/auth/getBearerToken.ts
import inquirer from "inquirer";
import jwt from "jsonwebtoken";
import open from "open";

// src/url.ts
var makeUrl = (baseUrl, path4) => [baseUrl.trim().replace(/\/+$/, ""), path4.trim().replace(/^\/+/, "")].join("/");

// src/auth/getBearerToken.ts
async function getBearerToken(baseUrl) {
  const { canOpen } = await inquirer.prompt([
    {
      type: "confirm",
      name: "canOpen",
      message: "Can we open a browser window to get a Uniform auth token?"
    }
  ]);
  if (canOpen) {
    open(makeUrl(baseUrl, "/cli-login"));
  }
  const tokenAnswer = await inquirer.prompt([
    {
      type: "password",
      name: "authToken",
      message: "Paste your Uniform auth token"
    }
  ]);
  const authToken = tokenAnswer.authToken.trim();
  if (!authToken) {
    throw new Error("No auth token provided.");
  }
  const decoded = jwt.decode(authToken, { complete: false });
  if (!decoded) {
    throw new Error("Could not parse the token pasted.");
  }
  if (typeof decoded.sub !== "string" || typeof decoded === "string") {
    throw new Error("Invalid token pasted.");
  }
  return {
    authToken,
    decoded: { ...decoded, sub: decoded.sub }
  };
}

// src/client.ts
import { z } from "zod";

// src/auth/api-key.ts
var READ_PERMISSIONS = ["PROJECT", "UPM_PUB", "OPT_PUB", "OPT_READ", "UPM_READ"];
var WRITE_PERMISSIONS = [
  "PROJECT",
  "UPM_SCHEMA",
  "UPM_READ",
  "UPM_PUB",
  "UPM_CREATE",
  "UPM_WRITE",
  "UPM_DELETE",
  "UPM_PUBLISH",
  "OPT_READ",
  "OPT_CREATE_ENRICHMENTS",
  "OPT_WRITE_ENRICHMENTS",
  "OPT_DELETE_ENRICHMENTS",
  "OPT_CREATE_INTENTS",
  "OPT_WRITE_INTENTS",
  "OPT_DELETE_INTENTS",
  "OPT_PUB",
  "OPT_PUBLISH",
  "OPT_CREATE_QUIRKS",
  "OPT_WRITE_QUIRKS",
  "OPT_DELETE_QUIRKS",
  "OPT_CREATE_SIGNALS",
  "OPT_WRITE_SIGNALS",
  "OPT_DELETE_SIGNALS",
  "OPT_CREATE_TESTS",
  "OPT_WRITE_TESTS",
  "OPT_DELETE_TESTS"
];
var makeApiKey = (teamId, projectId, name, permissions) => ({
  name,
  teamId,
  projects: [
    {
      projectId,
      permissions,
      roles: [],
      useCustom: true
    }
  ],
  email: "",
  identity_subject: "",
  isAdmin: false
});
var makeReadApiKey = (teamId, projectId) => makeApiKey(teamId, projectId, "Created by Uniform New (read)", READ_PERMISSIONS);
var makeWriteApiKey = (teamId, projectId) => makeApiKey(teamId, projectId, "Created by Uniform New (write)", WRITE_PERMISSIONS);

// src/client.ts
var createTeamOrProjectSchema = z.object({ id: z.string().min(1) });
var createApiKeySchema = z.object({ apiKey: z.string().min(1) });
var getLimitsSchema = z.object({
  limits: z.object({
    projects: z.array(
      z.object({ id: z.string().min(1), name: z.string().min(1), used: z.number(), limit: z.number() })
    )
  })
});
var createClient = (baseUrl, authToken) => {
  const request2 = async (path4, opts, allowedNon2xxStatusCodes = []) => {
    const res = await fetch(makeUrl(baseUrl, path4), {
      ...opts,
      headers: { Authorization: `Bearer ${authToken}` }
    });
    if (res.ok || allowedNon2xxStatusCodes.includes(res.status)) {
      return res;
    } else {
      throw new Error(
        `Non-2xx API response: ${opts.method} ${path4} responded with ${res.status} ${res.statusText}`
      );
    }
  };
  const requestJson = async (path4, opts, schema2, allowedNon2xxStatusCodes = []) => {
    const res = await request2(path4, opts, allowedNon2xxStatusCodes);
    const data = await res.json();
    const parseResult = schema2.safeParse(data);
    if (parseResult.success) {
      return parseResult.data;
    } else {
      throw new Error(`Invalid ${opts.method} ${path4} response: ${parseResult.error.message}`);
    }
  };
  return {
    createTeam: async (name) => {
      try {
        const result = await requestJson(
          "/api/v1/team",
          { method: "POST", body: JSON.stringify({ name }) },
          createTeamOrProjectSchema
        );
        return result.id;
      } catch (err) {
        throw new Error(`Failed to create team:
  ${err.message}`);
      }
    },
    createProject: async (teamId, name, previewUrl) => {
      try {
        const { limits } = await requestJson(
          `/api/v1/limits?teamId=${teamId}`,
          { method: "POST" },
          getLimitsSchema,
          // HTTP 402 Payment Required means that SOME limit has been exceeded.
          // We still want to check if there is some project type that is below limit.
          [402]
        );
        const projectTypeBelowLimit = limits.projects.find((project) => project.used < project.limit);
        if (!projectTypeBelowLimit) {
          throw new Error(
            "Usage exceeded: cannot create more projects. Please upgrade your plan or delete one of existing projects."
          );
        }
        const result = await requestJson(
          "/api/v1/project",
          {
            method: "PUT",
            body: JSON.stringify({
              teamId,
              name,
              projectTypeId: projectTypeBelowLimit.id,
              uiVersion: 3,
              previewUrl
            })
          },
          createTeamOrProjectSchema
        );
        return result.id;
      } catch (err) {
        throw new Error(`Failed to create project:
  ${err.message}`);
      }
    },
    createApiKeys: async (teamId, projectId) => {
      try {
        const { apiKey: readApiKey } = await requestJson(
          "/api/v1/members",
          {
            method: "PUT",
            body: JSON.stringify(makeReadApiKey(teamId, projectId))
          },
          createApiKeySchema
        );
        const { apiKey: writeApiKey } = await requestJson(
          "/api/v1/members",
          {
            method: "PUT",
            body: JSON.stringify(makeWriteApiKey(teamId, projectId))
          },
          createApiKeySchema
        );
        return { readApiKey, writeApiKey };
      } catch (err) {
        throw new Error(`Failed to create API key:
  ${err.message}`);
      }
    },
    registerMeshIntegration: async ({ teamId, manifest }) => {
      try {
        const { type } = await requestJson(
          "/api/v1/integration-definitions",
          {
            method: "PUT",
            body: JSON.stringify({ teamId, data: manifest })
          },
          z.object({ type: z.string() })
        );
        return type;
      } catch (err) {
        throw new Error(`Failed to register integration:
  ${err.message}`);
      }
    },
    installIntegration: async ({ projectId, type }) => {
      try {
        await request2("/api/v1/integration-installations", {
          method: "PUT",
          body: JSON.stringify({ projectId, type })
        });
      } catch (err) {
        throw new Error(`Failed to install integration to project:
  ${err.message}`);
      }
    }
  };
};

// src/npm.ts
import execa from "execa";
var runNpm = async (workDir, args, { inherit, env } = {}) => {
  let result;
  try {
    result = await execa("npm", args, {
      cwd: workDir,
      env: env ?? {},
      ...inherit ? { stdout: "inherit", stderr: "inherit" } : {}
    });
  } catch (err) {
    throw new Error(`Failed to execute npm ${args.join(" ")}
${err.message}`);
  }
  if (result.exitCode !== 0) {
    throw new Error(`Command npm ${args.join(" ")} exitted with code ${result == null ? void 0 : result.exitCode}}: ${result.stderr}`);
  }
  return result.stdout;
};

// src/projects/cloneStarter.ts
import crypto2 from "crypto";
import fs2 from "fs";
import fsj from "fs-jetpack";
import * as git from "isomorphic-git";
import * as http from "isomorphic-git/http/node/index.js";
import os from "os";
import path from "path";
async function cloneStarter({
  spin,
  githubPath,
  targetDir,
  dotEnvFile
}) {
  const done = await spin("Fetching starter code...");
  const cloneDir = path.join(os.tmpdir(), `uniform-new-${crypto2.randomBytes(20).toString("hex")}`);
  const [user, repo, ...pathSegments] = githubPath.split("/");
  try {
    await git.clone({
      fs: fs2,
      http,
      url: `https://github.com/${user}/${repo}`,
      dir: cloneDir,
      singleBranch: true,
      depth: 1
    });
  } catch (err) {
    throw new Error(`Failed to fetch starter code: ${err.message}`);
  }
  await done();
  if (fs2.existsSync(targetDir) && fs2.readdirSync(targetDir).length > 0) {
    throw new Error(`"${targetDir}" is not empty`);
  }
  const starterDir = path.join(cloneDir, ...pathSegments);
  fsj.copy(starterDir, targetDir, { overwrite: true });
  if (dotEnvFile) {
    fs2.writeFileSync(path.resolve(targetDir, ".env"), dotEnvFile, "utf-8");
  }
  console.log(`
Your project now lives in ${targetDir} \u2728`);
  return {
    runNpmInstall: async () => {
      console.log(`
Installing project dependencies...

`);
      await runNpm(targetDir, ["i"], { inherit: true });
    }
  };
}

// src/projects/getOrCreateProject.ts
import fs3, { existsSync as existsSync2, mkdirSync as mkdirSync2 } from "fs";
import inquirer2 from "inquirer";
import path2 from "path";
import slugify from "slugify";
var newProjectId = "$new";
async function getOrCreateProject({
  chooseExisting,
  createNew,
  teamId,
  user,
  explicitName,
  client,
  spin,
  checkTargetDir,
  explicitTargetDir,
  previewUrl,
  telemetry
}) {
  if (explicitName && !createNew) {
    throw new Error("Tried to specify explicit new project name when adding new project is not enabled.");
  }
  if (!createNew && !chooseExisting) {
    throw new Error("Must allow adding new, creating existing, or both.");
  }
  if (chooseExisting) {
    const { projectId, projectName } = await chooseExistingProject({ createNew, teamId, user });
    if (projectId !== newProjectId && projectName) {
      const targetDir = validateProjectName(projectName, checkTargetDir, explicitTargetDir);
      telemetry.send("project picked", { projectId, targetDir });
      return {
        projectId,
        projectName,
        targetDir
      };
    }
  }
  if (createNew) {
    const { projectName, targetDir } = await getNewProjectName({
      explicitName,
      checkTargetDir,
      explicitTargetDir
    });
    const projectId = await createProject({ client, projectName, spin, teamId, previewUrl });
    telemetry.send("project created", { projectId, targetDir });
    return {
      projectId,
      projectName,
      targetDir
    };
  }
  throw new Error("Insanity!");
}
async function getNewProjectName({
  explicitName,
  checkTargetDir,
  explicitTargetDir
}) {
  let projectName = explicitName;
  if (!projectName) {
    const answer = await inquirer2.prompt([
      {
        type: "input",
        name: "name",
        message: "What's your project name?",
        validate(input) {
          try {
            validateProjectName(input, checkTargetDir, explicitTargetDir);
            return true;
          } catch (e) {
            return e.message;
          }
        }
      }
    ]);
    projectName = answer.name;
  }
  projectName = projectName.trim();
  const targetDir = validateProjectName(projectName, checkTargetDir, explicitTargetDir);
  return { projectName, targetDir };
}
async function createProject({
  projectName,
  teamId,
  spin,
  client,
  previewUrl
}) {
  const done = await spin("Creating your new project...");
  const projectId = await client.createProject(teamId, projectName, previewUrl);
  await done();
  return projectId;
}
async function chooseExistingProject({
  createNew,
  teamId,
  user
}) {
  var _a, _b;
  const projects = (((_a = user.teams.find((t) => t.team.id === teamId)) == null ? void 0 : _a.team.sites) ?? []).map((t) => ({
    name: t.name,
    value: t.id
  }));
  const choices = createNew ? [{ name: "Create new project...", value: newProjectId }].concat(projects) : projects;
  const result = await inquirer2.prompt([
    {
      type: "list",
      name: "projectId",
      message: "Choose a project",
      choices
    }
  ]);
  return {
    projectId: result.projectId,
    projectName: (_b = projects.find((p) => p.value === result.projectId)) == null ? void 0 : _b.name
  };
}
function validateProjectName(projectName, checkTargetDir, explicitTargetDir) {
  projectName = projectName.trim();
  const projectNameSlug = slugify(projectName);
  if (projectName.length < 3 || projectNameSlug.length < 3) {
    throw new Error("Project name cannot be shorter than 3 characters.");
  }
  if (checkTargetDir) {
    let targetDir = explicitTargetDir ?? process.cwd();
    if (!existsSync2(targetDir)) {
      mkdirSync2(targetDir, { recursive: true });
    }
    if (fs3.readdirSync(targetDir).length > 0) {
      targetDir = path2.resolve(targetDir, projectNameSlug);
      if (fs3.existsSync(targetDir)) {
        throw new Error(`${targetDir} already exists, choose a different name.`);
      }
    }
    return targetDir;
  }
}

// src/teams/chooseTeam.ts
import inquirer3 from "inquirer";
async function chooseTeam(user, prompt, telemetry) {
  const result = await inquirer3.prompt([
    {
      type: "list",
      name: "teamId",
      message: prompt,
      choices: user.teams.map((team) => ({
        name: team.team.name,
        value: team.team.id
      }))
    }
  ]);
  telemetry.send("team picked", { teamId: result.teamId });
  return result;
}

// src/auth/user-info.ts
import { gql, request } from "graphql-request";
import { z as z2 } from "zod";
var query = gql`
  query GetUserInfo($subject: String!) {
    info: identities_by_pk(subject: $subject) {
      name
      email_address
      teams: organizations_identities(order_by: { organization: { name: asc } }) {
        team: organization {
          name
          id
          sites {
            name
            id
          }
        }
      }
    }
  }
`;
var schema = z2.object({
  info: z2.object({
    name: z2.string().min(1),
    email_address: z2.string().min(1).nullable(),
    teams: z2.array(
      z2.object({
        team: z2.object({
          name: z2.string().min(1),
          id: z2.string().min(1),
          sites: z2.array(
            z2.object({
              name: z2.string().min(1),
              id: z2.string().min(1)
            })
          )
        })
      })
    )
  })
});
var getUserInfo = async (baseUrl, authToken, subject) => {
  try {
    const endpoint = makeUrl(baseUrl, "/v1/graphql");
    const res = await request(endpoint, query, { subject }, { Authorization: `Bearer ${authToken}` });
    const parseResult = schema.safeParse(res);
    if (parseResult.success) {
      return parseResult.data.info;
    } else {
      throw new Error(`Invalid GraphQL response: ${parseResult.error.message}`);
    }
  } catch (err) {
    throw new Error(`Failed to fetch user account:
  ${err.message}`);
  }
};

// src/teams/fetchUserAndEnsureTeamExists.ts
async function fetchUserAndEnsureFirstTeamExists({
  baseUrl,
  auth: { authToken, decoded },
  spin,
  telemetry
}) {
  const uniformClient = createClient(baseUrl, authToken);
  const done = await spin("Fetching user information...");
  let user = await getUserInfo(baseUrl, authToken, decoded.sub);
  if (user.teams.length < 1) {
    await uniformClient.createTeam(`${user.name}'s team`);
    user = await getUserInfo(baseUrl, authToken, decoded.sub);
  }
  await done();
  telemetry.login(decoded.sub, user);
  return user;
}

// src/commands/new/commands/new.ts
async function newHandler({
  spin,
  projectName,
  apiHost,
  outputPath,
  telemetry
}) {
  console.info(
    `Welcome to Uniform New! Let's create ${projectName ? `"${projectName}"` : "a new project"}... \u2764\uFE0F`
  );
  const auth = await getBearerToken(apiHost);
  const { authToken } = auth;
  const uniformClient = createClient(apiHost, authToken);
  const user = await fetchUserAndEnsureFirstTeamExists({ auth, baseUrl: apiHost, spin, telemetry });
  const { teamId } = await chooseTeam(
    user,
    `Hey ${user.name}! Choose a Uniform team for your new project`,
    telemetry
  );
  const { frontendFramework } = await inquirer4.prompt([
    {
      type: "list",
      name: "frontendFramework",
      message: "Choose your preferred framework",
      choices: [
        {
          name: "Next.JS",
          value: "next"
        },
        {
          name: "Nuxt.JS",
          value: "nuxt"
        }
      ]
    }
  ]);
  telemetry.send("framework picked", { frontendFramework });
  const starters = {
    next: {
      helloWorld: {
        name: "Hello World (Recommended)",
        value: {
          githubUri: "uniformdev/examples/examples/nextjs-starter",
          serverUrl: "http://localhost:3000",
          previewPath: "/api/preview?secret=hello-world",
          installEnv: []
        }
      },
      csk: {
        name: "Component Starter Kit *New*",
        value: {
          githubUri: "uniformdev/uniform-component-starter-kit",
          serverUrl: "http://localhost:3000",
          previewPath: "/api/preview?secret=hello-world",
          installEnv: [["UNIFORM_PREVIEW_SECRET", "hello-world"]]
        }
      },
      uniformconf: {
        name: "Marketing Site Starter",
        value: {
          githubUri: "uniformdev/uniformconf",
          serverUrl: "http://localhost:3000",
          previewPath: "/api/preview?secret=uniformconf",
          installEnv: []
        }
      },
      javadrip: {
        name: "Commerce Starter",
        value: {
          githubUri: "uniformdev/commerce-starter",
          serverUrl: "http://localhost:3000",
          previewPath: "/api/preview?secret=javadrip",
          installEnv: []
        }
      }
    },
    nuxt: {
      helloWorld: {
        name: "Hello World (Recommended)",
        value: {
          githubUri: "uniformdev/examples/examples/nuxtjs-starter",
          serverUrl: "http://localhost:3000",
          previewPath: "/?preview=true",
          installEnv: [["NUXT_TELEMETRY_DISABLED", "1"]]
        }
      },
      uniformconf: {
        name: "Marketing Site Starter",
        value: {
          githubUri: "uniformdev/uniformconf-nuxt",
          serverUrl: "http://localhost:3000",
          previewPath: "/?preview=true",
          installEnv: [["NUXT_TELEMETRY_DISABLED", "1"]]
        }
      }
    }
  };
  const {
    starter: { githubUri, serverUrl, previewPath, installEnv }
  } = await inquirer4.prompt([
    {
      type: "list",
      name: "starter",
      message: `Choose one of the Uniform starters (for ${frontendFramework === "next" ? "Next.JS" : "Nuxt.JS"})`,
      choices: Object.values(starters[frontendFramework])
    }
  ]);
  telemetry.send("starter picked", { githubUri });
  const { projectId, targetDir } = await getOrCreateProject({
    client: uniformClient,
    createNew: true,
    chooseExisting: false,
    spin,
    teamId,
    user,
    explicitName: projectName,
    targetDir: outputPath,
    checkTargetDir: true,
    previewUrl: serverUrl + previewPath,
    telemetry
  });
  let done = await spin("Generating API keys...");
  const { readApiKey, writeApiKey } = await uniformClient.createApiKeys(teamId, projectId);
  await done();
  const dotEnvFile = [
    ["UNIFORM_PROJECT_ID", projectId],
    ["UNIFORM_API_KEY", readApiKey],
    ["UNIFORM_CLI_API_KEY", writeApiKey],
    ...installEnv
  ].concat(
    apiHost !== "https://uniform.app" ? [
      ["UNIFORM_CLI_BASE_URL", apiHost],
      ["UNIFORM_API_HOST", apiHost]
    ] : []
  ).map(([name, value]) => `${name}='${value}'`).join("\n") + "\n";
  await done();
  if (githubUri.endsWith("commerce-starter")) {
    const stableFakecommerceId = "fakecommerce-d04dcf12-f811-401d-add8-1fb81cfdb8a5";
    const canaryFakecommerceId = "fakecommerce-f94cf199-7ea4-46ce-ae8b-825668bb79bc";
    done = await spin("Installing Fake Commerce...");
    await uniformClient.installIntegration({
      projectId,
      type: apiHost.includes("canary") ? canaryFakecommerceId : stableFakecommerceId
    });
    await done();
  }
  const cloneStartTimestamp = Date.now();
  const { runNpmInstall } = await cloneStarter({
    githubPath: githubUri,
    spin,
    targetDir,
    dotEnvFile
  });
  telemetry.send("starter cloned", { duration: Date.now() - cloneStartTimestamp });
  const installStartTimestamp = Date.now();
  await runNpmInstall();
  telemetry.send("deps installed", { duration: Date.now() - installStartTimestamp });
  done = await spin("Creating components and compositions");
  await runNpm(targetDir, ["run", "uniform:push"]);
  await runNpm(targetDir, ["run", "uniform:publish"]);
  await done();
  telemetry.send("flow finished");
  console.log(`
  See your Uniform project and edit compositions by visiting:
  ${makeUrl(apiHost, `/projects/${projectId}`)}

`);
  if (process.platform.startsWith("win")) {
    console.log(`
Start your app server by executing:
  cd ${targetDir}
  npm run dev
`);
  } else {
    console.log(`
Hit Ctrl+C to exit; to run the server again execute:
cd ${targetDir}
npm run dev
`);
    console.log(`Your app is running at ${serverUrl} \u{1F389}
`);
    telemetry.send("server started");
    await runNpm(targetDir, ["run", "dev"]);
  }
}

// src/commands/new/commands/new-mesh-integration.ts
import { existsSync as existsSync3, mkdirSync as mkdirSync3, readdirSync, readFileSync as readFileSync2, writeFileSync as writeFileSync2 } from "fs";
import inquirer5 from "inquirer";
import path3 from "path";
import slugify2 from "slugify";
async function newMeshIntegrationHandler({
  spin,
  apiHost,
  outputPath,
  telemetry
}) {
  console.info(`Welcome to Uniform New Integration! Let's create a new Uniform integration... \u2764\uFE0F`);
  const auth = await getBearerToken(apiHost);
  const { authToken } = auth;
  const uniformClient = createClient(apiHost, authToken);
  const user = await fetchUserAndEnsureFirstTeamExists({ auth, baseUrl: apiHost, spin, telemetry });
  const { teamId } = await chooseTeam(
    user,
    `Hey ${user.name}! Choose a Uniform team to register your integration`,
    telemetry
  );
  const answer = await inquirer5.prompt([
    {
      type: "input",
      name: "name",
      message: "Please name your integration",
      validate(input) {
        try {
          validateIntegrationName(input, outputPath);
          return true;
        } catch (e) {
          return e.message;
        }
      }
    }
  ]);
  const name = answer.name;
  const { targetDir, typeSlug } = validateIntegrationName(answer.name, outputPath);
  const { runNpmInstall } = await cloneStarter({
    githubPath: `uniformdev/examples/examples/mesh-integration`,
    spin,
    targetDir
  });
  let done = await spin("Registering integration to team...");
  const pathToManifest = path3.resolve(targetDir, "mesh-manifest.json");
  if (!existsSync3(pathToManifest)) {
    throw new Error("Invalid integration starter cloned: missing `mesh-manifest.json`");
  }
  const manifestContents = readFileSync2(pathToManifest, "utf-8");
  const manifestJson = JSON.parse(manifestContents);
  manifestJson.type = typeSlug;
  manifestJson.displayName = name;
  writeFileSync2(pathToManifest, JSON.stringify(manifestJson, null, 2), "utf-8");
  const packageJsonPath = path3.resolve(targetDir, "package.json");
  const packageJson = JSON.parse(readFileSync2(packageJsonPath, "utf-8"));
  packageJson.name = typeSlug;
  writeFileSync2(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
  const fullMeshAppKey = await uniformClient.registerMeshIntegration({ teamId, manifest: manifestJson });
  await done();
  await runNpmInstall();
  console.log("\n\nChoose or create a project to install your integration to");
  const { projectId } = await getOrCreateProject({
    client: uniformClient,
    createNew: true,
    chooseExisting: true,
    spin,
    teamId,
    user,
    checkTargetDir: false,
    telemetry
  });
  done = await spin("Installing integration to project...");
  await uniformClient.installIntegration({ projectId, type: typeSlug });
  await done();
  console.log(`
Hit Ctrl/Cmd+C to exit; to run the mesh integration application again, execute:

  cd ${targetDir}
  npm run dev

See your integration registration by visiting:

  ${makeUrl(apiHost, `/teams/${teamId}/settings/custom-integrations`)}

See your integration's settings location by visiting:

  ${makeUrl(apiHost, `/projects/${projectId}/integrations/${fullMeshAppKey}`)}

`);
  console.log("Your integration is running at http://localhost:9000 \u{1F389}\n");
  await runNpm(targetDir, ["run", "dev"], { inherit: true });
}
function validateIntegrationName(integrationName, explicitOutputPath) {
  integrationName = integrationName.trim();
  const typeSlug = slugify2(integrationName, { lower: true });
  if (integrationName.length < 6 || typeSlug.length < 6) {
    throw new Error("Integration name cannot be shorter than 6 characters.");
  }
  let targetDir = explicitOutputPath ?? process.cwd();
  if (!existsSync3(targetDir)) {
    mkdirSync3(targetDir, { recursive: true });
  }
  if (readdirSync(targetDir).length > 0) {
    targetDir = path3.resolve(targetDir, typeSlug);
    if (existsSync3(targetDir)) {
      throw new Error(`${targetDir} directory already exists, choose a different name.`);
    }
  }
  return { targetDir, typeSlug };
}

// src/commands/new/index.ts
var stableApiHost = "https://uniform.app";
var apiHostDefault = process.env.UNIFORM_CLI_BASE_URL || stableApiHost;
var disableTelemetryDefault = !["", "0", "false", "no"].includes(
  process.env.UNIFORM_CLI_DISABLE_TELEMETRY || ""
);
var NewCmd = {
  command: "new [name]",
  builder: (y) => y.positional("name", {
    describe: "Name of a project",
    type: "string"
  }).option("apiHost", {
    describe: `Uniform host. Defaults to UNIFORM_CLI_BASE_URL env or ${stableApiHost}. Supports dotenv.`,
    default: apiHostDefault,
    demandOption: true,
    type: "string"
  }).option("outputPath", {
    alias: "o",
    description: "Specify where to store integration files. Defaults to cwd.",
    type: "string"
  }).option("disableTelemetry", {
    describe: "By default, usage information is sent to Uniform. Use this option or set UNIFORM_CLI_DISABLE_TELEMETRY to disable telemetry.",
    default: disableTelemetryDefault,
    demandOption: true,
    type: "boolean"
  }),
  describe: "Start a new Uniform project",
  handler: async function({ name, apiHost, outputPath, disableTelemetry }) {
    const { stopAllSpinners, spin } = makeSpinner();
    const telemetry = new Telemetry("cli new", disableTelemetry || apiHost !== stableApiHost);
    try {
      await newHandler({ spin, projectName: name, apiHost, outputPath, telemetry });
      stopAllSpinners();
      process.exit(0);
    } catch (err) {
      stopAllSpinners();
      telemetry.send("flow errored", { message: err.message });
      console.error(err.message);
      process.exitCode = 1;
    } finally {
      await telemetry.shutdown();
    }
  }
};
var NewMeshCmd = {
  command: "new-integration",
  builder: (y) => y.option("apiHost", {
    describe: `Uniform host. Defaults to UNIFORM_CLI_BASE_URL env or ${stableApiHost}. Supports dotenv.`,
    default: apiHostDefault,
    demandOption: true,
    type: "string"
  }).option("outputPath", {
    alias: "o",
    description: "Specify where to store integration files. Defaults to cwd.",
    type: "string"
  }).option("disableTelemetry", {
    describe: "By default, usage information is sent to Uniform. Use this option or set UNIFORM_CLI_DISABLE_TELEMETRY to disable telemetry.",
    default: disableTelemetryDefault,
    demandOption: true,
    type: "boolean"
  }),
  describe: "Start a new Uniform project",
  handler: async function({ apiHost, outputPath, disableTelemetry }) {
    const { stopAllSpinners, spin } = makeSpinner();
    const telemetry = new Telemetry("cli new mesh", disableTelemetry || apiHost !== stableApiHost);
    try {
      await newMeshIntegrationHandler({ spin, apiHost, outputPath, telemetry });
      stopAllSpinners();
      process.exit(0);
    } catch (err) {
      stopAllSpinners();
      telemetry.send("flow errored", { message: err.message });
      console.error(err.message);
      process.exitCode = 1;
    } finally {
      await telemetry.shutdown();
    }
  }
};

// src/commands/optimize/index.ts
import yargs13 from "yargs";

// src/commands/optimize/manifest.ts
import yargs12 from "yargs";

// src/commands/optimize/manifest/download.ts
import { gray as gray4, green as green3, red as red5, yellow as yellow2 } from "colorette";
import { writeFile as writeFile2 } from "fs";
import fetch2 from "isomorphic-unfetch";
import { exit as exit3 } from "process";

// src/constants.ts
var UniformBaseUrl = "https://uniform.app";

// src/commands/optimize/manifest/download.ts
var module = {
  command: "download [output]",
  describe: "Download intent manifest",
  builder: (yargs20) => yargs20.option("apiKey", {
    alias: "k",
    demandOption: true,
    string: true,
    default: process.env.UNIFORM_API_KEY,
    describe: "Uniform API key to use. Defaults to UNIFORM_API_KEY env if set."
  }).option("project", {
    describe: "Uniform project ID. Defaults to UOPT_CLI_PROJECT_ID or UNIFORM_PROJECT_ID env. Supports dotenv.",
    default: process.env.UOPT_CLI_PROJECT_ID ?? process.env.UNIFORM_PROJECT_ID,
    type: "string",
    alias: ["p"]
  }).option("preview", {
    describe: "If set, fetches the unpublished preview manifest (assuming your API key has permission)",
    default: false,
    type: "boolean",
    alias: ["d"]
  }).option("output", {
    string: true,
    alias: "o",
    default: process.env.UNIFORM_MANIFEST_PATH,
    describe: "Path to write manifest to. Defaults to UNIFORM_MANIFEST_PATH env if set."
  }),
  handler: async ({ apiKey, output, project, preview }) => {
    const isLegacyApiKey = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(
      apiKey
    );
    if (isLegacyApiKey) {
      console.error(
        yellow2(
          "WARNING: you appear to be using a deprecated type of API key. Keys like this will stop working soon; please create new keys on uniform.app."
        )
      );
    } else if (!project) {
      console.error(red5("You must specify the project ID"));
      exit3(1);
    }
    const baseUrl = resolveBaseUrl();
    const qs = new URLSearchParams();
    if (project) {
      qs.set("projectId", project);
    }
    if (preview) {
      qs.set("preview", "true");
    }
    const manifestUrl = `${baseUrl}api/v1/manifest?${qs.toString()}`;
    let fetchResponse = void 0;
    try {
      fetchResponse = await fetch2(manifestUrl, {
        headers: {
          "x-api-key": apiKey
        }
      });
      if (!fetchResponse.ok) {
        if (fetchResponse.status === 403) {
          throw `The API key ${apiKey} had no published data. This means it is either incorrectly entered, or intents have not been published since creating the API key.`;
        }
        throw `${fetchResponse.status} ${fetchResponse.statusText}, content ${await fetchResponse.text()}`;
      }
    } catch (e) {
      console.error(red5(`\u26A0 Error fetching intent manifest ${manifestUrl}`));
      console.error(gray4(`  \u2757 ${e}`));
      exit3(1);
    }
    let json;
    try {
      json = await fetchResponse.json();
    } catch (e) {
      console.error(red5(`\u26A0 Error parsing intent manifest ${manifestUrl}`));
      console.error(gray4(`  \u2757 ${e}`));
      console.error(`Response: ${await fetchResponse.text()}`);
      exit3(1);
    }
    const text = JSON.stringify(json, null, 2);
    if (output) {
      writeFile2(output, text, (error) => {
        if (error) {
          console.error(`Error writing file to ${output}
`, error);
          exit3(1);
        }
        console.log(green3(`\u2705 ${output} has been updated from ${manifestUrl}`));
      });
    } else {
      console.log(text);
    }
  }
};
var resolveBaseUrl = () => {
  let baseUrl = process.env.UNIFORM_CLI_BASE_URL || UniformBaseUrl;
  if (!baseUrl.endsWith("/")) {
    baseUrl += "/";
  }
  return baseUrl;
};
var download_default = module;

// src/commands/optimize/manifest.ts
var module2 = {
  command: "manifest <command>",
  describe: "Intent manifest commands",
  builder: () => {
    return yargs12.command(download_default);
  },
  handler: () => {
    yargs12.showHelp();
  }
};
var manifest_default = module2;

// src/commands/optimize/index.ts
var OptimizeCommand = {
  command: "optimize <command>",
  aliases: ["opt"],
  describe: "Uniform Optimize commands",
  builder: () => {
    return yargs13.command(manifest_default);
  },
  handler: () => {
    yargs13.showHelp();
  }
};

// src/commands/project-map/index.ts
import yargs16 from "yargs";

// src/commands/project-map/commands/projectMapDefinition.ts
import yargs14 from "yargs";

// src/commands/project-map/commands/ProjectMapDefinition/get.ts
import { UncachedProjectMapClient } from "@uniformdev/project-map";
var ProjectMapDefinitionGetModule = {
  command: "get <id>",
  describe: "Fetch a project map",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "ProjectMap UUID to fetch" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getProjectMapDefinition({ projectMapId: id });
    if (res.projectMaps.length === 0) {
      console.error("ProjectMap does not exist");
      process.exit(1);
    } else {
      emitWithFormat(res.projectMaps[0], format, filename);
    }
  }
};

// src/commands/project-map/commands/ProjectMapDefinition/list.ts
import { UncachedProjectMapClient as UncachedProjectMapClient2 } from "@uniformdev/project-map";
var ProjectMapDefinitionListModule = {
  command: "list",
  describe: "List of project maps",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getProjectMapDefinitions();
    emitWithFormat(res.projectMaps, format, filename);
  }
};

// src/commands/project-map/commands/ProjectMapDefinition/pull.ts
import { UncachedProjectMapClient as UncachedProjectMapClient3 } from "@uniformdev/project-map";

// src/commands/project-map/package.ts
function readContextPackage2(filename, assertExists) {
  return readUniformPackage(filename, assertExists);
}
function writeContextPackage2(filename, packageContents) {
  writeUniformPackage(filename, packageContents);
}

// src/commands/project-map/commands/ProjectMapDefinition/_util.ts
var selectIdentifier9 = (source) => source.id;
var selectDisplayName9 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/project-map/ProjectMapDefinitionEngineDataSource.ts
function createProjectMapDefinitionEngineDataSource({
  client
}) {
  async function* getObjects() {
    const projectMaps = (await client.getProjectMapDefinitions()).projectMaps;
    for await (const def of projectMaps) {
      const result = {
        id: selectIdentifier9(def),
        displayName: selectDisplayName9(def),
        providerId: selectIdentifier9(def),
        object: def
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.deleteProjectMap({ projectMapId: providerId });
    },
    writeObject: async (object) => {
      await client.upsertProjectMap({
        projectMap: object.object
      });
    }
  };
}

// src/commands/project-map/commands/ProjectMapDefinition/pull.ts
var ProjectMapDefinitionPullModule = {
  command: "pull <directory>",
  describe: "Pulls all project maps to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save project maps to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createProjectMapDefinitionEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage2(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.projectMaps ?? [],
        selectIdentifier: selectIdentifier9,
        selectDisplayName: selectDisplayName9,
        onSyncComplete: async (_, synced) => {
          packageContents.projectMaps = synced;
          writeContextPackage2(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier9,
        selectDisplayName: selectDisplayName9,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/project-map/commands/ProjectMapDefinition/push.ts
import { UncachedProjectMapClient as UncachedProjectMapClient4 } from "@uniformdev/project-map";
var ProjectMapDefinitionPushModule = {
  command: "push <directory>",
  describe: "Pushes all project maps from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read project maps from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage2(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.projectMaps ?? [],
        selectIdentifier: selectIdentifier9,
        selectDisplayName: selectDisplayName9
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier9,
        selectDisplayName: selectDisplayName9
      });
    }
    const target = createProjectMapDefinitionEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/project-map/commands/ProjectMapDefinition/remove.ts
import { UncachedProjectMapClient as UncachedProjectMapClient5 } from "@uniformdev/project-map";
var ProjectMapDefinitionRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a project map",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(yargs20.positional("id", { demandOption: true, describe: " UUID to delete" }))
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.deleteProjectMap({ projectMapId: id });
  }
};

// src/commands/project-map/commands/ProjectMapDefinition/update.ts
import { UncachedProjectMapClient as UncachedProjectMapClient6 } from "@uniformdev/project-map";
var ProjectMapDefinitionUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a project map",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("filename", { demandOption: true, describe: "Project map file to put" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsertProjectMap({ projectMap: file });
  }
};

// src/commands/project-map/commands/projectMapDefinition.ts
var ProjectMapDefinitionModule = {
  command: "definition <command>",
  describe: "Commands for ProjectMap Definitions",
  builder: (yargs20) => yargs20.command(ProjectMapDefinitionPullModule).command(ProjectMapDefinitionPushModule).command(ProjectMapDefinitionGetModule).command(ProjectMapDefinitionRemoveModule).command(ProjectMapDefinitionListModule).command(ProjectMapDefinitionUpdateModule).demandCommand(),
  handler: () => {
    yargs14.help();
  }
};

// src/commands/project-map/commands/projectMapNode.ts
import yargs15 from "yargs";

// src/commands/project-map/commands/ProjectMapNode/get.ts
import { UncachedProjectMapClient as UncachedProjectMapClient7 } from "@uniformdev/project-map";
var ProjectMapNodeGetModule = {
  command: "get <id> <projectMapId>",
  describe: "Fetch a project map node",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("id", { demandOption: true, describe: "ProjectMap Node UUID to fetch" }).positional("projectMapId", { demandOption: true, describe: "ProjectMap UUID to fetch from" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, projectMapId, format, project: projectId, filename }) => {
    var _a;
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient7({ apiKey, apiHost, fetch: fetch3, projectId });
    console.log("Debugging params for node get", { projectMapId, id, projectId });
    const res = await client.getNodes({ projectMapId, id });
    if (((_a = res.nodes) == null ? void 0 : _a.length) === 0) {
      console.error("Project map node does not exist");
      process.exit(1);
    } else {
      emitWithFormat({ nodes: res.nodes ?? [], projectMapId }, format, filename);
    }
  }
};

// src/commands/project-map/commands/ProjectMapNode/list.ts
import { UncachedProjectMapClient as UncachedProjectMapClient8 } from "@uniformdev/project-map";
var ProjectMapNodeListModule = {
  command: "list <projectMapId>",
  describe: "List project map nodes",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(
        yargs20.positional("projectMapId", { demandOption: true, describe: "ProjectMap UUID to fetch from" })
      )
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, projectMapId, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient8({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getNodes({ projectMapId });
    emitWithFormat({ nodes: res.nodes ?? [], projectMapId }, format, filename);
  }
};

// src/commands/project-map/commands/ProjectMapNode/pull.ts
import { UncachedProjectMapClient as UncachedProjectMapClient9 } from "@uniformdev/project-map";

// src/commands/project-map/commands/ProjectMapNode/_util.ts
var selectIdentifier10 = (source, projectId) => [
  projectId + source.projectMapId + source.id,
  projectId + source.projectMapId + source.path
];
var selectFilename = (source) => cleanFileName(`${source.pathSegment}_${source.id}`);
var selectDisplayName10 = (source) => `${source.name} (pid: ${source.id})`;

// src/commands/project-map/ProjectMapNodeEngineDataSource.ts
function createProjectMapNodeEngineDataSource({
  client,
  projectId
}) {
  async function* getObjects() {
    const projectMaps = (await client.getProjectMapDefinitions()).projectMaps;
    for (const projectMap of projectMaps) {
      const nodes = (await client.getNodes({ projectMapId: projectMap.id })).nodes;
      for await (const def of nodes ?? []) {
        if (def) {
          const result = {
            id: selectIdentifier10({ ...def, projectMapId: projectMap.id }, projectId),
            displayName: selectDisplayName10(def),
            providerId: selectIdentifier10({ ...def, projectMapId: projectMap.id }, projectId)[0],
            object: { ...def, projectMapId: projectMap.id }
          };
          yield result;
        }
      }
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId, object) => {
      await client.deleteProjectMapNode({
        nodeId: object.object.id,
        projectMapId: object.object.projectMapId
      });
    },
    writeObject: async (object) => {
      const nodeToUpsert = { ...object.object };
      await client.upsertProjectMapNodes({
        projectMapId: object.object.projectMapId,
        nodes: [{ node: nodeToUpsert }]
      });
    }
  };
}

// src/commands/project-map/commands/ProjectMapNode/pull.ts
var ProjectMapNodePullModule = {
  command: "pull <directory>",
  describe: "Pulls all project maps nodes to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save project maps to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient9({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createProjectMapNodeEngineDataSource({ client, projectId });
    let target;
    const isPackage = isPathAPackageFile(directory);
    const expandedSelectIdentifier = (object) => {
      return selectIdentifier10(object, projectId);
    };
    if (isPackage) {
      const packageContents = readContextPackage2(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.projectMapNodes ?? [],
        selectIdentifier: expandedSelectIdentifier,
        selectDisplayName: selectDisplayName10,
        onSyncComplete: async (_, synced) => {
          packageContents.projectMapNodes = synced;
          writeContextPackage2(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: expandedSelectIdentifier,
        selectDisplayName: selectDisplayName10,
        format,
        selectFilename
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/project-map/commands/ProjectMapNode/push.ts
import { UncachedProjectMapClient as UncachedProjectMapClient10 } from "@uniformdev/project-map";
var ProjectMapNodePushModule = {
  command: "push <directory>",
  describe: "Pushes all project maps nodes from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read project maps from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient10({
      apiKey,
      apiHost,
      fetch: fetch3,
      projectId
    });
    let source;
    const isPackage = isPathAPackageFile(directory);
    const expandedSelectIdentifier = (object) => {
      return selectIdentifier10(object, projectId);
    };
    if (isPackage) {
      const packageContents = readContextPackage2(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.projectMapNodes ?? [],
        selectIdentifier: expandedSelectIdentifier,
        selectDisplayName: selectDisplayName10
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: expandedSelectIdentifier,
        selectDisplayName: selectDisplayName10,
        selectFilename
      });
    }
    const target = createProjectMapNodeEngineDataSource({ client, projectId });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/project-map/commands/ProjectMapNode/remove.ts
import { UncachedProjectMapClient as UncachedProjectMapClient11 } from "@uniformdev/project-map";
var ProjectMapNodeRemoveModule = {
  command: "remove <id> <projectMapId>",
  aliases: ["delete", "rm"],
  describe: "Delete a project map node",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("id", { demandOption: true, describe: "ProjectMap Node UUID to delete" }).positional("projectMapId", { demandOption: true, describe: "ProjectMap UUID to delete from" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, projectMapId, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient11({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.deleteProjectMapNode({ projectMapId, nodeId: id });
  }
};

// src/commands/project-map/commands/ProjectMapNode/update.ts
import { UncachedProjectMapClient as UncachedProjectMapClient12 } from "@uniformdev/project-map";
var ProjectMapNodeUpdateModule = {
  command: "update <filename> <projectMapId>",
  aliases: ["put"],
  describe: "Insert or update a project map node",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("filename", { demandOption: true, describe: "ProjectMap node file with nodes data" }).positional("projectMapId", { demandOption: true, describe: "ProjectMap UUID to put into" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, projectMapId, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedProjectMapClient12({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsertProjectMapNodes({ nodes: [{ node: file }], projectMapId });
  }
};

// src/commands/project-map/commands/projectMapNode.ts
var ProjectMapNodeModule = {
  command: "node <command>",
  describe: "Commands for ProjectMap Nodes",
  builder: (yargs20) => yargs20.command(ProjectMapNodePullModule).command(ProjectMapNodePushModule).command(ProjectMapNodeGetModule).command(ProjectMapNodeRemoveModule).command(ProjectMapNodeListModule).command(ProjectMapNodeUpdateModule).demandCommand(),
  handler: () => {
    yargs15.help();
  }
};

// src/commands/project-map/index.ts
var ProjectMapCommand = {
  command: "project-map <command>",
  aliases: ["prm"],
  describe: "Uniform ProjectMap commands",
  builder: (yargs20) => yargs20.command(ProjectMapNodeModule).command(ProjectMapDefinitionModule).demandCommand(),
  handler: () => {
    yargs16.showHelp();
  }
};

// src/commands/redirect/index.ts
import yargs18 from "yargs";

// src/commands/redirect/commands/redirect.ts
import yargs17 from "yargs";

// src/commands/redirect/commands/RedirectDefinition/get.ts
import { UncachedRedirectClient } from "@uniformdev/redirect";
var RedirectDefinitionGetModule = {
  command: "get <id>",
  describe: "Fetch a redirect",
  builder: (yargs20) => withFormatOptions(
    withApiOptions(
      withProjectOptions(yargs20.positional("id", { demandOption: true, describe: "Redirect UUID to fetch" }))
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, id, format, project: projectId, filename }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedRedirectClient({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getRedirect({ id });
    if (!res) {
      console.error("Redirect does not exist");
      process.exit(1);
    } else {
      emitWithFormat(res, format, filename);
    }
  }
};

// src/commands/redirect/commands/RedirectDefinition/list.ts
import { UncachedRedirectClient as UncachedRedirectClient2 } from "@uniformdev/redirect";
var RedirectDefinitionListModule = {
  command: "list",
  describe: "List of redirects",
  aliases: ["ls"],
  builder: (yargs20) => withFormatOptions(withApiOptions(withProjectOptions(yargs20))),
  handler: async ({ apiHost, apiKey, proxy, format, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedRedirectClient2({ apiKey, apiHost, fetch: fetch3, projectId });
    const res = await client.getRedirects({});
    emitWithFormat(res, format, filename);
  }
};

// src/commands/redirect/commands/RedirectDefinition/pull.ts
import { UncachedRedirectClient as UncachedRedirectClient3 } from "@uniformdev/redirect";

// src/commands/redirect/package.ts
function readContextPackage3(filename, assertExists) {
  return readUniformPackage(filename, assertExists);
}
function writeContextPackage3(filename, packageContents) {
  writeUniformPackage(filename, packageContents);
}

// src/commands/redirect/commands/RedirectDefinition/_util.ts
var selectIdentifier11 = (source) => source.id;
var selectFilename2 = (source) => {
  const index = source.sourceUrl.lastIndexOf("/");
  return cleanFileName(source.sourceUrl.substring(index + 1)) + `_${source.id}`;
};
var selectDisplayName11 = (source) => {
  let pathName = source.sourceUrl;
  if (pathName.length > 30) {
    const slashIndex = source.sourceUrl.indexOf("/", source.sourceUrl.length - 30);
    pathName = "..." + pathName.substring(slashIndex);
  }
  return `${pathName} (id: ${source.id})`;
};

// src/commands/redirect/RedirectEngineDataSource.ts
function createRedirectDefinitionEngineDataSource({
  client
}) {
  async function* getObjects() {
    const { redirects } = await client.getRedirects();
    for await (const def of redirects) {
      const result = {
        id: selectIdentifier11(def.redirect),
        displayName: selectDisplayName11(def.redirect),
        providerId: selectIdentifier11(def.redirect),
        object: def.redirect
      };
      yield result;
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await client.deleteRedirect(providerId);
    },
    writeObject: async (object) => {
      await client.upsertRedirect(object.object);
    }
  };
}

// src/commands/redirect/commands/RedirectDefinition/pull.ts
var RedirectDefinitionPullModule = {
  command: "pull <directory>",
  describe: "Pulls all redirects to local files in a directory",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to save redirects to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",
          type: "string"
        }).option("format", {
          alias: ["f"],
          describe: "Output format",
          default: "yaml",
          choices: ["yaml", "json"],
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes no files",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    format,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedRedirectClient3({ apiKey, apiHost, fetch: fetch3, projectId });
    const source = createRedirectDefinitionEngineDataSource({ client });
    let target;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage3(directory, false);
      target = await createArraySyncEngineDataSource({
        objects: packageContents.redirects ?? [],
        selectIdentifier: selectIdentifier11,
        selectDisplayName: selectDisplayName11,
        onSyncComplete: async (_, synced) => {
          packageContents.redirects = synced;
          writeContextPackage3(directory, packageContents);
        }
      });
    } else {
      target = await createFileSyncEngineDataSource({
        directory,
        selectFilename: selectFilename2,
        selectIdentifier: selectIdentifier11,
        selectDisplayName: selectDisplayName11,
        format
      });
    }
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/redirect/commands/RedirectDefinition/push.ts
import { UncachedRedirectClient as UncachedRedirectClient4 } from "@uniformdev/redirect";
var RedirectDefinitionPushModule = {
  command: "push <directory>",
  describe: "Pushes all redirects from files in a directory or package to Uniform",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      withDiffOptions(
        yargs20.positional("directory", {
          describe: "Directory to read redirects from. If a filename is used, a package will be read instead.",
          type: "string"
        }).option("what-if", {
          alias: ["w"],
          describe: "What-if mode reports what would be done but changes nothing",
          default: false,
          type: "boolean"
        }).option("mode", {
          alias: ["m"],
          describe: 'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',
          choices: ["create", "createOrUpdate", "mirror"],
          default: "mirror",
          type: "string"
        })
      )
    )
  ),
  handler: async ({
    apiHost,
    apiKey,
    proxy,
    directory,
    mode,
    whatIf,
    project: projectId,
    diff: diffMode
  }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedRedirectClient4({ apiKey, apiHost, fetch: fetch3, projectId });
    let source;
    const isPackage = isPathAPackageFile(directory);
    if (isPackage) {
      const packageContents = readContextPackage3(directory, true);
      source = await createArraySyncEngineDataSource({
        objects: packageContents.redirects ?? [],
        selectIdentifier: selectIdentifier11,
        selectDisplayName: selectDisplayName11
      });
    } else {
      source = await createFileSyncEngineDataSource({
        directory,
        selectIdentifier: selectIdentifier11,
        selectDisplayName: selectDisplayName11
      });
    }
    const target = createRedirectDefinitionEngineDataSource({ client });
    await syncEngine({
      source,
      target,
      mode,
      whatIf,
      log: createSyncEngineConsoleLogger({ diffMode })
    });
  }
};

// src/commands/redirect/commands/RedirectDefinition/remove.ts
import { UncachedRedirectClient as UncachedRedirectClient5 } from "@uniformdev/redirect";
var RedirectDefinitionRemoveModule = {
  command: "remove <id>",
  aliases: ["delete", "rm"],
  describe: "Delete a redirect",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(yargs20.positional("id", { demandOption: true, describe: " UUID to delete" }))
  ),
  handler: async ({ apiHost, apiKey, proxy, id, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedRedirectClient5({ apiKey, apiHost, fetch: fetch3, projectId });
    await client.deleteRedirect(id);
  }
};

// src/commands/redirect/commands/RedirectDefinition/update.ts
import { UncachedRedirectClient as UncachedRedirectClient6 } from "@uniformdev/redirect";
var RedirectDefinitionUpdateModule = {
  command: "update <filename>",
  aliases: ["put"],
  describe: "Insert or update a redirect",
  builder: (yargs20) => withApiOptions(
    withProjectOptions(
      yargs20.positional("filename", { demandOption: true, describe: "Redirect file to put" })
    )
  ),
  handler: async ({ apiHost, apiKey, proxy, filename, project: projectId }) => {
    const fetch3 = nodeFetchProxy(proxy);
    const client = new UncachedRedirectClient6({ apiKey, apiHost, fetch: fetch3, projectId });
    const file = readFileToObject(filename);
    await client.upsertRedirect(file);
  }
};

// src/commands/redirect/commands/redirect.ts
var RedirectDefinitionModule = {
  command: "definition <command>",
  describe: "Commands for Redirect Definitions",
  builder: (yargs20) => yargs20.command(RedirectDefinitionPullModule).command(RedirectDefinitionPushModule).command(RedirectDefinitionGetModule).command(RedirectDefinitionRemoveModule).command(RedirectDefinitionListModule).command(RedirectDefinitionUpdateModule).demandCommand(),
  handler: () => {
    yargs17.help();
  }
};

// src/commands/redirect/index.ts
var RedirectCommand = {
  command: "redirect <command>",
  aliases: ["red"],
  describe: "Uniform Redirect commands",
  builder: (yargs20) => yargs20.command(RedirectDefinitionModule).demandCommand(),
  handler: () => {
    yargs18.showHelp();
  }
};

// src/index.ts
dotenv.config();
var yarggery = yargs19(hideBin(process.argv));
yarggery.command(CanvasCommand).command(ContextCommand).command(ProjectMapCommand).command(RedirectCommand).command(NewCmd).command(NewMeshCmd).command(OptimizeCommand).demandCommand(1, "").strict().help().argv;
